"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nostr-tools";
exports.ids = ["vendor-chunks/nostr-tools"];
exports.modules = {

/***/ "(ssr)/./node_modules/nostr-tools/lib/esm/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nostr-tools/lib/esm/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Relay: () => (/* binding */ Relay),\n/* harmony export */   SimplePool: () => (/* binding */ SimplePool),\n/* harmony export */   finalizeEvent: () => (/* binding */ finalizeEvent),\n/* harmony export */   fj: () => (/* binding */ fakejson_exports),\n/* harmony export */   generateSecretKey: () => (/* binding */ generateSecretKey),\n/* harmony export */   getEventHash: () => (/* binding */ getEventHash),\n/* harmony export */   getFilterLimit: () => (/* binding */ getFilterLimit),\n/* harmony export */   getPublicKey: () => (/* binding */ getPublicKey),\n/* harmony export */   kinds: () => (/* binding */ kinds_exports),\n/* harmony export */   matchFilter: () => (/* binding */ matchFilter),\n/* harmony export */   matchFilters: () => (/* binding */ matchFilters),\n/* harmony export */   mergeFilters: () => (/* binding */ mergeFilters),\n/* harmony export */   nip04: () => (/* binding */ nip04_exports),\n/* harmony export */   nip05: () => (/* binding */ nip05_exports),\n/* harmony export */   nip10: () => (/* binding */ nip10_exports),\n/* harmony export */   nip11: () => (/* binding */ nip11_exports),\n/* harmony export */   nip13: () => (/* binding */ nip13_exports),\n/* harmony export */   nip18: () => (/* binding */ nip18_exports),\n/* harmony export */   nip19: () => (/* binding */ nip19_exports),\n/* harmony export */   nip21: () => (/* binding */ nip21_exports),\n/* harmony export */   nip25: () => (/* binding */ nip25_exports),\n/* harmony export */   nip27: () => (/* binding */ nip27_exports),\n/* harmony export */   nip28: () => (/* binding */ nip28_exports),\n/* harmony export */   nip30: () => (/* binding */ nip30_exports),\n/* harmony export */   nip39: () => (/* binding */ nip39_exports),\n/* harmony export */   nip42: () => (/* binding */ nip42_exports),\n/* harmony export */   nip44: () => (/* binding */ nip44_exports),\n/* harmony export */   nip47: () => (/* binding */ nip47_exports),\n/* harmony export */   nip57: () => (/* binding */ nip57_exports),\n/* harmony export */   nip98: () => (/* binding */ nip98_exports),\n/* harmony export */   parseReferences: () => (/* binding */ parseReferences),\n/* harmony export */   serializeEvent: () => (/* binding */ serializeEvent),\n/* harmony export */   sortEvents: () => (/* binding */ sortEvents),\n/* harmony export */   utils: () => (/* binding */ utils_exports),\n/* harmony export */   validateEvent: () => (/* binding */ validateEvent),\n/* harmony export */   verifiedSymbol: () => (/* binding */ verifiedSymbol),\n/* harmony export */   verifyEvent: () => (/* binding */ verifyEvent)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _scure_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @scure/base */ \"(ssr)/./node_modules/@scure/base/lib/esm/index.js\");\n/* harmony import */ var _noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/ciphers/aes */ \"(ssr)/./node_modules/@noble/ciphers/esm/aes.js\");\n/* harmony import */ var _noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @noble/ciphers/chacha */ \"(ssr)/./node_modules/@noble/ciphers/esm/chacha.js\");\n/* harmony import */ var _noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @noble/ciphers/utils */ \"(ssr)/./node_modules/@noble/ciphers/esm/utils.js\");\n/* harmony import */ var _noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @noble/hashes/hkdf */ \"(ssr)/./node_modules/@noble/hashes/esm/hkdf.js\");\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(ssr)/./node_modules/@noble/hashes/esm/hmac.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// pure.ts\n\n\n\n// core.ts\nvar verifiedSymbol = Symbol(\"verified\");\nvar isRecord = (obj) => obj instanceof Object;\nfunction validateEvent(event) {\n  if (!isRecord(event))\n    return false;\n  if (typeof event.kind !== \"number\")\n    return false;\n  if (typeof event.content !== \"string\")\n    return false;\n  if (typeof event.created_at !== \"number\")\n    return false;\n  if (typeof event.pubkey !== \"string\")\n    return false;\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/))\n    return false;\n  if (!Array.isArray(event.tags))\n    return false;\n  for (let i2 = 0; i2 < event.tags.length; i2++) {\n    let tag = event.tags[i2];\n    if (!Array.isArray(tag))\n      return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\")\n        return false;\n    }\n  }\n  return true;\n}\nfunction sortEvents(events) {\n  return events.sort((a, b) => {\n    if (a.created_at !== b.created_at) {\n      return b.created_at - a.created_at;\n    }\n    return a.id.localeCompare(b.id);\n  });\n}\n\n// pure.ts\n\n\n// utils.ts\nvar utils_exports = {};\n__export(utils_exports, {\n  Queue: () => Queue,\n  QueueNode: () => QueueNode,\n  binarySearch: () => binarySearch,\n  insertEventIntoAscendingList: () => insertEventIntoAscendingList,\n  insertEventIntoDescendingList: () => insertEventIntoDescendingList,\n  normalizeURL: () => normalizeURL,\n  utf8Decoder: () => utf8Decoder,\n  utf8Encoder: () => utf8Encoder\n});\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  if (url.indexOf(\"://\") === -1)\n    url = \"wss://\" + url;\n  let p = new URL(url);\n  p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n  if (p.pathname.endsWith(\"/\"))\n    p.pathname = p.pathname.slice(0, -1);\n  if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n    p.port = \"\";\n  p.searchParams.sort();\n  p.hash = \"\";\n  return p.toString();\n}\nfunction insertEventIntoDescendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return b.created_at - event.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction insertEventIntoAscendingList(sortedArray, event) {\n  const [idx, found] = binarySearch(sortedArray, (b) => {\n    if (event.id === b.id)\n      return 0;\n    if (event.created_at === b.created_at)\n      return -1;\n    return event.created_at - b.created_at;\n  });\n  if (!found) {\n    sortedArray.splice(idx, 0, event);\n  }\n  return sortedArray;\n}\nfunction binarySearch(arr, compare) {\n  let start = 0;\n  let end = arr.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const cmp = compare(arr[mid]);\n    if (cmp === 0) {\n      return [mid, true];\n    }\n    if (cmp < 0) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return [start, false];\n}\nvar QueueNode = class {\n  value;\n  next = null;\n  prev = null;\n  constructor(message) {\n    this.value = message;\n  }\n};\nvar Queue = class {\n  first;\n  last;\n  constructor() {\n    this.first = null;\n    this.last = null;\n  }\n  enqueue(value) {\n    const newNode = new QueueNode(value);\n    if (!this.last) {\n      this.first = newNode;\n      this.last = newNode;\n    } else if (this.last === this.first) {\n      this.last = newNode;\n      this.last.prev = this.first;\n      this.first.next = newNode;\n    } else {\n      newNode.prev = this.last;\n      this.last.next = newNode;\n      this.last = newNode;\n    }\n    return true;\n  }\n  dequeue() {\n    if (!this.first)\n      return null;\n    if (this.first === this.last) {\n      const target2 = this.first;\n      this.first = null;\n      this.last = null;\n      return target2.value;\n    }\n    const target = this.first;\n    this.first = target.next;\n    return target.value;\n  }\n};\n\n// pure.ts\nvar JS = class {\n  generateSecretKey() {\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.utils.randomPrivateKey();\n  }\n  getPublicKey(secretKey) {\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n  }\n  finalizeEvent(t, secretKey) {\n    const event = t;\n    event.pubkey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n    event.id = getEventHash(event);\n    event.sig = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.sign(getEventHash(event), secretKey));\n    event[verifiedSymbol] = true;\n    return event;\n  }\n  verifyEvent(event) {\n    if (typeof event[verifiedSymbol] === \"boolean\")\n      return event[verifiedSymbol];\n    const hash = getEventHash(event);\n    if (hash !== event.id) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n    try {\n      const valid = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.verify(event.sig, hash, event.pubkey);\n      event[verifiedSymbol] = valid;\n      return valid;\n    } catch (err) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n  }\n};\nfunction serializeEvent(evt) {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);\n}\nfunction getEventHash(event) {\n  let eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(serializeEvent(event)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(eventHash);\n}\nvar i = new JS();\nvar generateSecretKey = i.generateSecretKey;\nvar getPublicKey = i.getPublicKey;\nvar finalizeEvent = i.finalizeEvent;\nvar verifyEvent = i.verifyEvent;\n\n// kinds.ts\nvar kinds_exports = {};\n__export(kinds_exports, {\n  Application: () => Application,\n  BadgeAward: () => BadgeAward,\n  BadgeDefinition: () => BadgeDefinition,\n  BlockedRelaysList: () => BlockedRelaysList,\n  BookmarkList: () => BookmarkList,\n  Bookmarksets: () => Bookmarksets,\n  Calendar: () => Calendar,\n  CalendarEventRSVP: () => CalendarEventRSVP,\n  ChannelCreation: () => ChannelCreation,\n  ChannelHideMessage: () => ChannelHideMessage,\n  ChannelMessage: () => ChannelMessage,\n  ChannelMetadata: () => ChannelMetadata,\n  ChannelMuteUser: () => ChannelMuteUser,\n  ClassifiedListing: () => ClassifiedListing,\n  ClientAuth: () => ClientAuth,\n  CommunitiesList: () => CommunitiesList,\n  CommunityDefinition: () => CommunityDefinition,\n  CommunityPostApproval: () => CommunityPostApproval,\n  Contacts: () => Contacts,\n  CreateOrUpdateProduct: () => CreateOrUpdateProduct,\n  CreateOrUpdateStall: () => CreateOrUpdateStall,\n  Curationsets: () => Curationsets,\n  Date: () => Date2,\n  DraftClassifiedListing: () => DraftClassifiedListing,\n  DraftLong: () => DraftLong,\n  Emojisets: () => Emojisets,\n  EncryptedDirectMessage: () => EncryptedDirectMessage,\n  EncryptedDirectMessages: () => EncryptedDirectMessages,\n  EventDeletion: () => EventDeletion,\n  FileMetadata: () => FileMetadata,\n  FileServerPreference: () => FileServerPreference,\n  Followsets: () => Followsets,\n  GenericRepost: () => GenericRepost,\n  Genericlists: () => Genericlists,\n  HTTPAuth: () => HTTPAuth,\n  Handlerinformation: () => Handlerinformation,\n  Handlerrecommendation: () => Handlerrecommendation,\n  Highlights: () => Highlights,\n  InterestsList: () => InterestsList,\n  Interestsets: () => Interestsets,\n  JobFeedback: () => JobFeedback,\n  JobRequest: () => JobRequest,\n  JobResult: () => JobResult,\n  Label: () => Label,\n  LightningPubRPC: () => LightningPubRPC,\n  LiveChatMessage: () => LiveChatMessage,\n  LiveEvent: () => LiveEvent,\n  LongFormArticle: () => LongFormArticle,\n  Metadata: () => Metadata,\n  Mutelist: () => Mutelist,\n  NWCWalletInfo: () => NWCWalletInfo,\n  NWCWalletRequest: () => NWCWalletRequest,\n  NWCWalletResponse: () => NWCWalletResponse,\n  NostrConnect: () => NostrConnect,\n  OpenTimestamps: () => OpenTimestamps,\n  Pinlist: () => Pinlist,\n  ProblemTracker: () => ProblemTracker,\n  ProfileBadges: () => ProfileBadges,\n  PublicChatsList: () => PublicChatsList,\n  Reaction: () => Reaction,\n  RecommendRelay: () => RecommendRelay,\n  RelayList: () => RelayList,\n  Relaysets: () => Relaysets,\n  Report: () => Report,\n  Reporting: () => Reporting,\n  Repost: () => Repost,\n  SearchRelaysList: () => SearchRelaysList,\n  ShortTextNote: () => ShortTextNote,\n  Time: () => Time,\n  UserEmojiList: () => UserEmojiList,\n  UserStatuses: () => UserStatuses,\n  Zap: () => Zap,\n  ZapGoal: () => ZapGoal,\n  ZapRequest: () => ZapRequest,\n  classifyKind: () => classifyKind,\n  isEphemeralKind: () => isEphemeralKind,\n  isParameterizedReplaceableKind: () => isParameterizedReplaceableKind,\n  isRegularKind: () => isRegularKind,\n  isReplaceableKind: () => isReplaceableKind\n});\nfunction isRegularKind(kind) {\n  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);\n}\nfunction isReplaceableKind(kind) {\n  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;\n}\nfunction isEphemeralKind(kind) {\n  return 2e4 <= kind && kind < 3e4;\n}\nfunction isParameterizedReplaceableKind(kind) {\n  return 3e4 <= kind && kind < 4e4;\n}\nfunction classifyKind(kind) {\n  if (isRegularKind(kind))\n    return \"regular\";\n  if (isReplaceableKind(kind))\n    return \"replaceable\";\n  if (isEphemeralKind(kind))\n    return \"ephemeral\";\n  if (isParameterizedReplaceableKind(kind))\n    return \"parameterized\";\n  return \"unknown\";\n}\nvar Metadata = 0;\nvar ShortTextNote = 1;\nvar RecommendRelay = 2;\nvar Contacts = 3;\nvar EncryptedDirectMessage = 4;\nvar EncryptedDirectMessages = 4;\nvar EventDeletion = 5;\nvar Repost = 6;\nvar Reaction = 7;\nvar BadgeAward = 8;\nvar GenericRepost = 16;\nvar ChannelCreation = 40;\nvar ChannelMetadata = 41;\nvar ChannelMessage = 42;\nvar ChannelHideMessage = 43;\nvar ChannelMuteUser = 44;\nvar OpenTimestamps = 1040;\nvar FileMetadata = 1063;\nvar LiveChatMessage = 1311;\nvar ProblemTracker = 1971;\nvar Report = 1984;\nvar Reporting = 1984;\nvar Label = 1985;\nvar CommunityPostApproval = 4550;\nvar JobRequest = 5999;\nvar JobResult = 6999;\nvar JobFeedback = 7e3;\nvar ZapGoal = 9041;\nvar ZapRequest = 9734;\nvar Zap = 9735;\nvar Highlights = 9802;\nvar Mutelist = 1e4;\nvar Pinlist = 10001;\nvar RelayList = 10002;\nvar BookmarkList = 10003;\nvar CommunitiesList = 10004;\nvar PublicChatsList = 10005;\nvar BlockedRelaysList = 10006;\nvar SearchRelaysList = 10007;\nvar InterestsList = 10015;\nvar UserEmojiList = 10030;\nvar FileServerPreference = 10096;\nvar NWCWalletInfo = 13194;\nvar LightningPubRPC = 21e3;\nvar ClientAuth = 22242;\nvar NWCWalletRequest = 23194;\nvar NWCWalletResponse = 23195;\nvar NostrConnect = 24133;\nvar HTTPAuth = 27235;\nvar Followsets = 3e4;\nvar Genericlists = 30001;\nvar Relaysets = 30002;\nvar Bookmarksets = 30003;\nvar Curationsets = 30004;\nvar ProfileBadges = 30008;\nvar BadgeDefinition = 30009;\nvar Interestsets = 30015;\nvar CreateOrUpdateStall = 30017;\nvar CreateOrUpdateProduct = 30018;\nvar LongFormArticle = 30023;\nvar DraftLong = 30024;\nvar Emojisets = 30030;\nvar Application = 30078;\nvar LiveEvent = 30311;\nvar UserStatuses = 30315;\nvar ClassifiedListing = 30402;\nvar DraftClassifiedListing = 30403;\nvar Date2 = 31922;\nvar Time = 31923;\nvar Calendar = 31924;\nvar CalendarEventRSVP = 31925;\nvar Handlerrecommendation = 31989;\nvar Handlerinformation = 31990;\nvar CommunityDefinition = 34550;\n\n// filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      let values = filter[`#${tagName}`];\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))\n        return false;\n    }\n  }\n  if (filter.since && event.created_at < filter.since)\n    return false;\n  if (filter.until && event.created_at > filter.until)\n    return false;\n  return true;\n}\nfunction matchFilters(filters, event) {\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    if (matchFilter(filters[i2], event)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction mergeFilters(...filters) {\n  let result = {};\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    let filter = filters[i2];\n    Object.entries(filter).forEach(([property, values]) => {\n      if (property === \"kinds\" || property === \"ids\" || property === \"authors\" || property[0] === \"#\") {\n        result[property] = result[property] || [];\n        for (let v = 0; v < values.length; v++) {\n          let value = values[v];\n          if (!result[property].includes(value))\n            result[property].push(value);\n        }\n      }\n    });\n    if (filter.limit && (!result.limit || filter.limit > result.limit))\n      result.limit = filter.limit;\n    if (filter.until && (!result.until || filter.until > result.until))\n      result.until = filter.until;\n    if (filter.since && (!result.since || filter.since < result.since))\n      result.since = filter.since;\n  }\n  return result;\n}\nfunction getFilterLimit(filter) {\n  if (filter.ids && !filter.ids.length)\n    return 0;\n  if (filter.kinds && !filter.kinds.length)\n    return 0;\n  if (filter.authors && !filter.authors.length)\n    return 0;\n  return Math.min(\n    Math.max(0, filter.limit ?? Infinity),\n    filter.ids?.length ?? Infinity,\n    filter.authors?.length && filter.kinds?.every((kind) => isReplaceableKind(kind)) ? filter.authors.length * filter.kinds.length : Infinity\n  );\n}\n\n// fakejson.ts\nvar fakejson_exports = {};\n__export(fakejson_exports, {\n  getHex64: () => getHex64,\n  getInt: () => getInt,\n  getSubscriptionId: () => getSubscriptionId,\n  matchEventId: () => matchEventId,\n  matchEventKind: () => matchEventKind,\n  matchEventPubkey: () => matchEventPubkey\n});\nfunction getHex64(json, field) {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\nfunction getInt(json, field) {\n  let len = field.length;\n  let idx = json.indexOf(`\"${field}\":`) + len + 3;\n  let sliced = json.slice(idx);\n  let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n  return parseInt(sliced.slice(0, end), 10);\n}\nfunction getSubscriptionId(json) {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n  if (idx === -1)\n    return null;\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n  if (pstart === -1)\n    return null;\n  let start = idx + 7 + 1 + pstart;\n  let pend = json.slice(start + 1, 80).indexOf(`\"`);\n  if (pend === -1)\n    return null;\n  let end = start + 1 + pend;\n  return json.slice(start + 1, end);\n}\nfunction matchEventId(json, id) {\n  return id === getHex64(json, \"id\");\n}\nfunction matchEventPubkey(json, pubkey) {\n  return pubkey === getHex64(json, \"pubkey\");\n}\nfunction matchEventKind(json, kind) {\n  return kind === getInt(json, \"kind\");\n}\n\n// nip42.ts\nvar nip42_exports = {};\n__export(nip42_exports, {\n  makeAuthEvent: () => makeAuthEvent\n});\nfunction makeAuthEvent(relayURL, challenge) {\n  return {\n    kind: ClientAuth,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", relayURL],\n      [\"challenge\", challenge]\n    ],\n    content: \"\"\n  };\n}\n\n// helpers.ts\nasync function yieldThread() {\n  return new Promise((resolve) => {\n    const ch = new MessageChannel();\n    const handler = () => {\n      ch.port1.removeEventListener(\"message\", handler);\n      resolve();\n    };\n    ch.port1.addEventListener(\"message\", handler);\n    ch.port2.postMessage(0);\n    ch.port1.start();\n  });\n}\nvar alwaysTrue = (t) => {\n  t[verifiedSymbol] = true;\n  return true;\n};\n\n// abstract-relay.ts\nvar AbstractRelay = class {\n  url;\n  _connected = false;\n  onclose = null;\n  onnotice = (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`);\n  _onauth = null;\n  baseEoseTimeout = 4400;\n  connectionTimeout = 4400;\n  openSubs = /* @__PURE__ */ new Map();\n  connectionTimeoutHandle;\n  connectionPromise;\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  ws;\n  incomingMessageQueue = new Queue();\n  queueRunning = false;\n  challenge;\n  serial = 0;\n  verifyEvent;\n  _WebSocket;\n  constructor(url, opts) {\n    this.url = normalizeURL(url);\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation || WebSocket;\n  }\n  static async connect(url, opts) {\n    const relay = new AbstractRelay(url, opts);\n    await relay.connect();\n    return relay;\n  }\n  closeAllSubscriptions(reason) {\n    for (let [_, sub] of this.openSubs) {\n      sub.close(reason);\n    }\n    this.openSubs.clear();\n    for (let [_, ep] of this.openEventPublishes) {\n      ep.reject(new Error(reason));\n    }\n    this.openEventPublishes.clear();\n    for (let [_, cr] of this.openCountRequests) {\n      cr.reject(new Error(reason));\n    }\n    this.openCountRequests.clear();\n  }\n  get connected() {\n    return this._connected;\n  }\n  async connect() {\n    if (this.connectionPromise)\n      return this.connectionPromise;\n    this.challenge = void 0;\n    this.connectionPromise = new Promise((resolve, reject) => {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        reject(\"connection timed out\");\n        this.connectionPromise = void 0;\n        this.onclose?.();\n        this.closeAllSubscriptions(\"relay connection timed out\");\n      }, this.connectionTimeout);\n      try {\n        this.ws = new this._WebSocket(this.url);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      this.ws.onopen = () => {\n        clearTimeout(this.connectionTimeoutHandle);\n        this._connected = true;\n        resolve();\n      };\n      this.ws.onerror = (ev) => {\n        reject(ev.message);\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection errored\");\n        }\n      };\n      this.ws.onclose = async () => {\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection closed\");\n        }\n      };\n      this.ws.onmessage = this._onmessage.bind(this);\n    });\n    return this.connectionPromise;\n  }\n  async runQueue() {\n    this.queueRunning = true;\n    while (true) {\n      if (false === this.handleNext()) {\n        break;\n      }\n      await yieldThread();\n    }\n    this.queueRunning = false;\n  }\n  handleNext() {\n    const json = this.incomingMessageQueue.dequeue();\n    if (!json) {\n      return false;\n    }\n    const subid = getSubscriptionId(json);\n    if (subid) {\n      const so = this.openSubs.get(subid);\n      if (!so) {\n        return;\n      }\n      const id = getHex64(json, \"id\");\n      const alreadyHave = so.alreadyHaveEvent?.(id);\n      so.receivedEvent?.(this, id);\n      if (alreadyHave) {\n        return;\n      }\n    }\n    try {\n      let data = JSON.parse(json);\n      switch (data[0]) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(data[1]);\n          const event = data[2];\n          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {\n            so.onevent(event);\n          }\n          return;\n        }\n        case \"COUNT\": {\n          const id = data[1];\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(data[1]);\n          if (!so)\n            return;\n          so.receivedEose();\n          return;\n        }\n        case \"OK\": {\n          const id = data[1];\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          if (ok)\n            ep.resolve(reason);\n          else\n            ep.reject(new Error(reason));\n          this.openEventPublishes.delete(id);\n          return;\n        }\n        case \"CLOSED\": {\n          const id = data[1];\n          const so = this.openSubs.get(id);\n          if (!so)\n            return;\n          so.closed = true;\n          so.close(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onnotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.challenge = data[1];\n          this._onauth?.(data[1]);\n          return;\n        }\n      }\n    } catch (err) {\n      return;\n    }\n  }\n  async send(message) {\n    if (!this.connectionPromise)\n      throw new Error(\"sending on closed connection\");\n    this.connectionPromise.then(() => {\n      this.ws?.send(message);\n    });\n  }\n  async auth(signAuthEvent) {\n    if (!this.challenge)\n      throw new Error(\"can't perform auth, no challenge was received\");\n    const evt = await signAuthEvent(makeAuthEvent(this.url, this.challenge));\n    const ret = new Promise((resolve, reject) => {\n      this.openEventPublishes.set(evt.id, { resolve, reject });\n    });\n    this.send('[\"AUTH\",' + JSON.stringify(evt) + \"]\");\n    return ret;\n  }\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      this.openEventPublishes.set(event.id, { resolve, reject });\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    return ret;\n  }\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  subscribe(filters, params) {\n    const subscription = this.prepareSubscription(filters, params);\n    subscription.fire();\n    return subscription;\n  }\n  prepareSubscription(filters, params) {\n    this.serial++;\n    const id = params.id || \"sub:\" + this.serial;\n    const subscription = new Subscription(this, id, filters, params);\n    this.openSubs.set(id, subscription);\n    return subscription;\n  }\n  close() {\n    this.closeAllSubscriptions(\"relay connection closed by us\");\n    this._connected = false;\n    this.ws?.close();\n  }\n  _onmessage(ev) {\n    this.incomingMessageQueue.enqueue(ev.data);\n    if (!this.queueRunning) {\n      this.runQueue();\n    }\n  }\n};\nvar Subscription = class {\n  relay;\n  id;\n  closed = false;\n  eosed = false;\n  filters;\n  alreadyHaveEvent;\n  receivedEvent;\n  onevent;\n  oneose;\n  onclose;\n  eoseTimeout;\n  eoseTimeoutHandle;\n  constructor(relay, id, filters, params) {\n    this.relay = relay;\n    this.filters = filters;\n    this.id = id;\n    this.alreadyHaveEvent = params.alreadyHaveEvent;\n    this.receivedEvent = params.receivedEvent;\n    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;\n    this.oneose = params.oneose;\n    this.onclose = params.onclose;\n    this.onevent = params.onevent || ((event) => {\n      console.warn(\n        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,\n        event\n      );\n    });\n  }\n  fire() {\n    this.relay.send('[\"REQ\",\"' + this.id + '\",' + JSON.stringify(this.filters).substring(1));\n    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);\n  }\n  receivedEose() {\n    if (this.eosed)\n      return;\n    clearTimeout(this.eoseTimeoutHandle);\n    this.eosed = true;\n    this.oneose?.();\n  }\n  close(reason = \"closed by caller\") {\n    if (!this.closed && this.relay.connected) {\n      this.relay.send('[\"CLOSE\",' + JSON.stringify(this.id) + \"]\");\n      this.closed = true;\n    }\n    this.relay.openSubs.delete(this.id);\n    this.onclose?.(reason);\n  }\n};\n\n// relay.ts\nvar _WebSocket;\ntry {\n  _WebSocket = WebSocket;\n} catch {\n}\nvar Relay = class extends AbstractRelay {\n  constructor(url) {\n    super(url, { verifyEvent, websocketImplementation: _WebSocket });\n  }\n  static async connect(url) {\n    const relay = new Relay(url);\n    await relay.connect();\n    return relay;\n  }\n};\n\n// abstract-pool.ts\nvar AbstractSimplePool = class {\n  relays = /* @__PURE__ */ new Map();\n  seenOn = /* @__PURE__ */ new Map();\n  trackRelays = false;\n  verifyEvent;\n  trustedRelayURLs = /* @__PURE__ */ new Set();\n  _WebSocket;\n  constructor(opts) {\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation;\n  }\n  async ensureRelay(url, params) {\n    url = normalizeURL(url);\n    let relay = this.relays.get(url);\n    if (!relay) {\n      relay = new AbstractRelay(url, {\n        verifyEvent: this.trustedRelayURLs.has(url) ? alwaysTrue : this.verifyEvent,\n        websocketImplementation: this._WebSocket\n      });\n      if (params?.connectionTimeout)\n        relay.connectionTimeout = params.connectionTimeout;\n      this.relays.set(url, relay);\n    }\n    await relay.connect();\n    return relay;\n  }\n  close(relays) {\n    relays.map(normalizeURL).forEach((url) => {\n      this.relays.get(url)?.close();\n    });\n  }\n  subscribeMany(relays, filters, params) {\n    return this.subscribeManyMap(Object.fromEntries(relays.map((url) => [url, filters])), params);\n  }\n  subscribeManyMap(requests, params) {\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const relaysLength = Object.keys(requests).length;\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === relaysLength) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === relaysLength) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      Object.entries(requests).map(async (req, i2, arr) => {\n        if (arr.indexOf(req) !== i2) {\n          handleClose(i2, \"duplicate url\");\n          return;\n        }\n        let [url, filters] = req;\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe(filters, {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => handleClose(i2, reason),\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close() {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close();\n        });\n      }\n    };\n  }\n  subscribeManyEose(relays, filters, params) {\n    const subcloser = this.subscribeMany(relays, filters, {\n      ...params,\n      oneose() {\n        subcloser.close();\n      }\n    });\n    return subcloser;\n  }\n  async querySync(relays, filter, params) {\n    return new Promise(async (resolve) => {\n      const events = [];\n      this.subscribeManyEose(relays, [filter], {\n        ...params,\n        onevent(event) {\n          events.push(event);\n        },\n        onclose(_) {\n          resolve(events);\n        }\n      });\n    });\n  }\n  async get(relays, filter, params) {\n    filter.limit = 1;\n    const events = await this.querySync(relays, filter, params);\n    events.sort((a, b) => b.created_at - a.created_at);\n    return events[0] || null;\n  }\n  publish(relays, event) {\n    return relays.map(normalizeURL).map(async (url, i2, arr) => {\n      if (arr.indexOf(url) !== i2) {\n        return Promise.reject(\"duplicate url\");\n      }\n      let r = await this.ensureRelay(url);\n      return r.publish(event);\n    });\n  }\n};\n\n// pool.ts\nvar _WebSocket2;\ntry {\n  _WebSocket2 = WebSocket;\n} catch {\n}\nvar SimplePool = class extends AbstractSimplePool {\n  constructor() {\n    super({ verifyEvent, websocketImplementation: _WebSocket2 });\n  }\n};\n\n// nip19.ts\nvar nip19_exports = {};\n__export(nip19_exports, {\n  BECH32_REGEX: () => BECH32_REGEX,\n  Bech32MaxSize: () => Bech32MaxSize,\n  decode: () => decode,\n  encodeBytes: () => encodeBytes,\n  naddrEncode: () => naddrEncode,\n  neventEncode: () => neventEncode,\n  noteEncode: () => noteEncode,\n  nprofileEncode: () => nprofileEncode,\n  npubEncode: () => npubEncode,\n  nrelayEncode: () => nrelayEncode,\n  nsecEncode: () => nsecEncode\n});\n\n\nvar Bech32MaxSize = 5e3;\nvar BECH32_REGEX = /[\\x21-\\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;\nfunction integerToUint8Array(number) {\n  const uint8Array = new Uint8Array(4);\n  uint8Array[0] = number >> 24 & 255;\n  uint8Array[1] = number >> 16 & 255;\n  uint8Array[2] = number >> 8 & 255;\n  uint8Array[3] = number & 255;\n  return uint8Array;\n}\nfunction decode(nip19) {\n  let { prefix, words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(nip19, Bech32MaxSize);\n  let data = new Uint8Array(_scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words));\n  switch (prefix) {\n    case \"nprofile\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nprofile\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      return {\n        type: \"nprofile\",\n        data: {\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nevent\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nevent\");\n      if (tlv[0][0].length !== 32)\n        throw new Error(\"TLV 0 should be 32 bytes\");\n      if (tlv[2] && tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (tlv[3] && tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"nevent\",\n        data: {\n          id: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[0][0]),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],\n          author: tlv[2]?.[0] ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]) : void 0,\n          kind: tlv[3]?.[0] ? parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16) : void 0\n        }\n      };\n    }\n    case \"naddr\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for naddr\");\n      if (!tlv[2]?.[0])\n        throw new Error(\"missing TLV 2 for naddr\");\n      if (tlv[2][0].length !== 32)\n        throw new Error(\"TLV 2 should be 32 bytes\");\n      if (!tlv[3]?.[0])\n        throw new Error(\"missing TLV 3 for naddr\");\n      if (tlv[3][0].length !== 4)\n        throw new Error(\"TLV 3 should be 4 bytes\");\n      return {\n        type: \"naddr\",\n        data: {\n          identifier: utf8Decoder.decode(tlv[0][0]),\n          pubkey: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[2][0]),\n          kind: parseInt((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(tlv[3][0]), 16),\n          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []\n        }\n      };\n    }\n    case \"nrelay\": {\n      let tlv = parseTLV(data);\n      if (!tlv[0]?.[0])\n        throw new Error(\"missing TLV 0 for nrelay\");\n      return {\n        type: \"nrelay\",\n        data: utf8Decoder.decode(tlv[0][0])\n      };\n    }\n    case \"nsec\":\n      return { type: prefix, data };\n    case \"npub\":\n    case \"note\":\n      return { type: prefix, data: (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(data) };\n    default:\n      throw new Error(`unknown prefix ${prefix}`);\n  }\n}\nfunction parseTLV(data) {\n  let result = {};\n  let rest = data;\n  while (rest.length > 0) {\n    let t = rest[0];\n    let l = rest[1];\n    let v = rest.slice(2, 2 + l);\n    rest = rest.slice(2 + l);\n    if (v.length < l)\n      throw new Error(`not enough data to read on TLV ${t}`);\n    result[t] = result[t] || [];\n    result[t].push(v);\n  }\n  return result;\n}\nfunction nsecEncode(key) {\n  return encodeBytes(\"nsec\", key);\n}\nfunction npubEncode(hex) {\n  return encodeBytes(\"npub\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction noteEncode(hex) {\n  return encodeBytes(\"note\", (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex));\n}\nfunction encodeBech32(prefix, data) {\n  let words = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.toWords(data);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.encode(prefix, words, Bech32MaxSize);\n}\nfunction encodeBytes(prefix, bytes) {\n  return encodeBech32(prefix, bytes);\n}\nfunction nprofileEncode(profile) {\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(profile.pubkey)],\n    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))\n  });\n  return encodeBech32(\"nprofile\", data);\n}\nfunction neventEncode(event) {\n  let kindArray;\n  if (event.kind !== void 0) {\n    kindArray = integerToUint8Array(event.kind);\n  }\n  let data = encodeTLV({\n    0: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.id)],\n    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: event.author ? [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(event.author)] : [],\n    3: kindArray ? [new Uint8Array(kindArray)] : []\n  });\n  return encodeBech32(\"nevent\", data);\n}\nfunction naddrEncode(addr) {\n  let kind = new ArrayBuffer(4);\n  new DataView(kind).setUint32(0, addr.kind, false);\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(addr.identifier)],\n    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),\n    2: [(0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(addr.pubkey)],\n    3: [new Uint8Array(kind)]\n  });\n  return encodeBech32(\"naddr\", data);\n}\nfunction nrelayEncode(url) {\n  let data = encodeTLV({\n    0: [utf8Encoder.encode(url)]\n  });\n  return encodeBech32(\"nrelay\", data);\n}\nfunction encodeTLV(tlv) {\n  let entries = [];\n  Object.entries(tlv).reverse().forEach(([t, vs]) => {\n    vs.forEach((v) => {\n      let entry = new Uint8Array(v.length + 2);\n      entry.set([parseInt(t)], 0);\n      entry.set([v.length], 1);\n      entry.set(v, 2);\n      entries.push(entry);\n    });\n  });\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...entries);\n}\n\n// references.ts\nvar mentionRegex = /\\bnostr:((note|npub|naddr|nevent|nprofile)1\\w+)\\b|#\\[(\\d+)\\]/g;\nfunction parseReferences(evt) {\n  let references = [];\n  for (let ref of evt.content.matchAll(mentionRegex)) {\n    if (ref[2]) {\n      try {\n        let { type, data } = decode(ref[1]);\n        switch (type) {\n          case \"npub\": {\n            references.push({\n              text: ref[0],\n              profile: { pubkey: data, relays: [] }\n            });\n            break;\n          }\n          case \"nprofile\": {\n            references.push({\n              text: ref[0],\n              profile: data\n            });\n            break;\n          }\n          case \"note\": {\n            references.push({\n              text: ref[0],\n              event: { id: data, relays: [] }\n            });\n            break;\n          }\n          case \"nevent\": {\n            references.push({\n              text: ref[0],\n              event: data\n            });\n            break;\n          }\n          case \"naddr\": {\n            references.push({\n              text: ref[0],\n              address: data\n            });\n            break;\n          }\n        }\n      } catch (err) {\n      }\n    } else if (ref[3]) {\n      let idx = parseInt(ref[3], 10);\n      let tag = evt.tags[idx];\n      if (!tag)\n        continue;\n      switch (tag[0]) {\n        case \"p\": {\n          references.push({\n            text: ref[0],\n            profile: { pubkey: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"e\": {\n          references.push({\n            text: ref[0],\n            event: { id: tag[1], relays: tag[2] ? [tag[2]] : [] }\n          });\n          break;\n        }\n        case \"a\": {\n          try {\n            let [kind, pubkey, identifier] = tag[1].split(\":\");\n            references.push({\n              text: ref[0],\n              address: {\n                identifier,\n                pubkey,\n                kind: parseInt(kind, 10),\n                relays: tag[2] ? [tag[2]] : []\n              }\n            });\n          } catch (err) {\n          }\n          break;\n        }\n      }\n    }\n  }\n  return references;\n}\n\n// nip04.ts\nvar nip04_exports = {};\n__export(nip04_exports, {\n  decrypt: () => decrypt,\n  encrypt: () => encrypt\n});\n\n\n\n\nasync function encrypt(secretKey, pubkey, text) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  const key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  const normalizedKey = getNormalizedX(key);\n  let iv = Uint8Array.from((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(16));\n  let plaintext = utf8Encoder.encode(text);\n  let ciphertext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).encrypt(plaintext);\n  let ctb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(ciphertext));\n  let ivb64 = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(new Uint8Array(iv.buffer));\n  return `${ctb64}?iv=${ivb64}`;\n}\nasync function decrypt(secretKey, pubkey, data) {\n  const privkey = secretKey instanceof Uint8Array ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(secretKey) : secretKey;\n  let [ctb64, ivb64] = data.split(\"?iv=\");\n  let key = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkey, \"02\" + pubkey);\n  let normalizedKey = getNormalizedX(key);\n  let iv = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ivb64);\n  let ciphertext = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(ctb64);\n  let plaintext = (0,_noble_ciphers_aes__WEBPACK_IMPORTED_MODULE_4__.cbc)(normalizedKey, iv).decrypt(ciphertext);\n  return utf8Decoder.decode(plaintext);\n}\nfunction getNormalizedX(key) {\n  return key.slice(1, 33);\n}\n\n// nip05.ts\nvar nip05_exports = {};\n__export(nip05_exports, {\n  NIP05_REGEX: () => NIP05_REGEX,\n  isValid: () => isValid,\n  queryProfile: () => queryProfile,\n  searchDomain: () => searchDomain,\n  useFetchImplementation: () => useFetchImplementation\n});\nvar NIP05_REGEX = /^(?:([\\w.+-]+)@)?([\\w_-]+(\\.[\\w_-]+)+)$/;\nvar _fetch;\ntry {\n  _fetch = fetch;\n} catch {\n}\nfunction useFetchImplementation(fetchImplementation) {\n  _fetch = fetchImplementation;\n}\nasync function searchDomain(domain, query = \"\") {\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;\n    const res = await _fetch(url, { redirect: \"error\" });\n    const json = await res.json();\n    return json.names;\n  } catch (_) {\n    return {};\n  }\n}\nasync function queryProfile(fullname) {\n  const match = fullname.match(NIP05_REGEX);\n  if (!match)\n    return null;\n  const [_, name = \"_\", domain] = match;\n  try {\n    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;\n    const res = await (await _fetch(url, { redirect: \"error\" })).json();\n    let pubkey = res.names[name];\n    return pubkey ? { pubkey, relays: res.relays?.[pubkey] } : null;\n  } catch (_e) {\n    return null;\n  }\n}\nasync function isValid(pubkey, nip05) {\n  let res = await queryProfile(nip05);\n  return res ? res.pubkey === pubkey : false;\n}\n\n// nip10.ts\nvar nip10_exports = {};\n__export(nip10_exports, {\n  parse: () => parse\n});\nfunction parse(event) {\n  const result = {\n    reply: void 0,\n    root: void 0,\n    mentions: [],\n    profiles: []\n  };\n  const eTags = [];\n  for (const tag of event.tags) {\n    if (tag[0] === \"e\" && tag[1]) {\n      eTags.push(tag);\n    }\n    if (tag[0] === \"p\" && tag[1]) {\n      result.profiles.push({\n        pubkey: tag[1],\n        relays: tag[2] ? [tag[2]] : []\n      });\n    }\n  }\n  for (let eTagIndex = 0; eTagIndex < eTags.length; eTagIndex++) {\n    const eTag = eTags[eTagIndex];\n    const [_, eTagEventId, eTagRelayUrl, eTagMarker] = eTag;\n    const eventPointer = {\n      id: eTagEventId,\n      relays: eTagRelayUrl ? [eTagRelayUrl] : []\n    };\n    const isFirstETag = eTagIndex === 0;\n    const isLastETag = eTagIndex === eTags.length - 1;\n    if (eTagMarker === \"root\") {\n      result.root = eventPointer;\n      continue;\n    }\n    if (eTagMarker === \"reply\") {\n      result.reply = eventPointer;\n      continue;\n    }\n    if (eTagMarker === \"mention\") {\n      result.mentions.push(eventPointer);\n      continue;\n    }\n    if (isFirstETag) {\n      result.root = eventPointer;\n      continue;\n    }\n    if (isLastETag) {\n      result.reply = eventPointer;\n      continue;\n    }\n    result.mentions.push(eventPointer);\n  }\n  return result;\n}\n\n// nip11.ts\nvar nip11_exports = {};\n__export(nip11_exports, {\n  fetchRelayInformation: () => fetchRelayInformation,\n  useFetchImplementation: () => useFetchImplementation2\n});\nvar _fetch2;\ntry {\n  _fetch2 = fetch;\n} catch {\n}\nfunction useFetchImplementation2(fetchImplementation) {\n  _fetch2 = fetchImplementation;\n}\nasync function fetchRelayInformation(url) {\n  return await (await fetch(url.replace(\"ws://\", \"http://\").replace(\"wss://\", \"https://\"), {\n    headers: { Accept: \"application/nostr+json\" }\n  })).json();\n}\n\n// nip13.ts\nvar nip13_exports = {};\n__export(nip13_exports, {\n  getPow: () => getPow,\n  minePow: () => minePow\n});\nfunction getPow(hex) {\n  let count = 0;\n  for (let i2 = 0; i2 < hex.length; i2++) {\n    const nibble = parseInt(hex[i2], 16);\n    if (nibble === 0) {\n      count += 4;\n    } else {\n      count += Math.clz32(nibble) - 28;\n      break;\n    }\n  }\n  return count;\n}\nfunction minePow(unsigned, difficulty) {\n  let count = 0;\n  const event = unsigned;\n  const tag = [\"nonce\", count.toString(), difficulty.toString()];\n  event.tags.push(tag);\n  while (true) {\n    const now = Math.floor(new Date().getTime() / 1e3);\n    if (now !== event.created_at) {\n      count = 0;\n      event.created_at = now;\n    }\n    tag[1] = (++count).toString();\n    event.id = getEventHash(event);\n    if (getPow(event.id) >= difficulty) {\n      break;\n    }\n  }\n  return event;\n}\n\n// nip18.ts\nvar nip18_exports = {};\n__export(nip18_exports, {\n  finishRepostEvent: () => finishRepostEvent,\n  getRepostedEvent: () => getRepostedEvent,\n  getRepostedEventPointer: () => getRepostedEventPointer\n});\nfunction finishRepostEvent(t, reposted, relayUrl, privateKey) {\n  return finalizeEvent(\n    {\n      kind: Repost,\n      tags: [...t.tags ?? [], [\"e\", reposted.id, relayUrl], [\"p\", reposted.pubkey]],\n      content: t.content === \"\" ? \"\" : JSON.stringify(reposted),\n      created_at: t.created_at\n    },\n    privateKey\n  );\n}\nfunction getRepostedEventPointer(event) {\n  if (event.kind !== Repost) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag?.[2]].filter((x) => typeof x === \"string\"),\n    author: lastPTag?.[1]\n  };\n}\nfunction getRepostedEvent(event, { skipVerification } = {}) {\n  const pointer = getRepostedEventPointer(event);\n  if (pointer === void 0 || event.content === \"\") {\n    return void 0;\n  }\n  let repostedEvent;\n  try {\n    repostedEvent = JSON.parse(event.content);\n  } catch (error) {\n    return void 0;\n  }\n  if (repostedEvent.id !== pointer.id) {\n    return void 0;\n  }\n  if (!skipVerification && !verifyEvent(repostedEvent)) {\n    return void 0;\n  }\n  return repostedEvent;\n}\n\n// nip21.ts\nvar nip21_exports = {};\n__export(nip21_exports, {\n  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,\n  parse: () => parse2,\n  test: () => test\n});\nvar NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);\nfunction test(value) {\n  return typeof value === \"string\" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);\n}\nfunction parse2(uri) {\n  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));\n  if (!match)\n    throw new Error(`Invalid Nostr URI: ${uri}`);\n  return {\n    uri: match[0],\n    value: match[1],\n    decoded: decode(match[1])\n  };\n}\n\n// nip25.ts\nvar nip25_exports = {};\n__export(nip25_exports, {\n  finishReactionEvent: () => finishReactionEvent,\n  getReactedEventPointer: () => getReactedEventPointer\n});\nfunction finishReactionEvent(t, reacted, privateKey) {\n  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === \"e\" || tag[0] === \"p\"));\n  return finalizeEvent(\n    {\n      ...t,\n      kind: Reaction,\n      tags: [...t.tags ?? [], ...inheritedTags, [\"e\", reacted.id], [\"p\", reacted.pubkey]],\n      content: t.content ?? \"+\"\n    },\n    privateKey\n  );\n}\nfunction getReactedEventPointer(event) {\n  if (event.kind !== Reaction) {\n    return void 0;\n  }\n  let lastETag;\n  let lastPTag;\n  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {\n    const tag = event.tags[i2];\n    if (tag.length >= 2) {\n      if (tag[0] === \"e\" && lastETag === void 0) {\n        lastETag = tag;\n      } else if (tag[0] === \"p\" && lastPTag === void 0) {\n        lastPTag = tag;\n      }\n    }\n  }\n  if (lastETag === void 0 || lastPTag === void 0) {\n    return void 0;\n  }\n  return {\n    id: lastETag[1],\n    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),\n    author: lastPTag[1]\n  };\n}\n\n// nip27.ts\nvar nip27_exports = {};\n__export(nip27_exports, {\n  matchAll: () => matchAll,\n  regex: () => regex,\n  replaceAll: () => replaceAll\n});\nvar regex = () => new RegExp(`\\\\b${NOSTR_URI_REGEX.source}\\\\b`, \"g\");\nfunction* matchAll(content) {\n  const matches = content.matchAll(regex());\n  for (const match of matches) {\n    try {\n      const [uri, value] = match;\n      yield {\n        uri,\n        value,\n        decoded: decode(value),\n        start: match.index,\n        end: match.index + uri.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll(content, replacer) {\n  return content.replaceAll(regex(), (uri, value) => {\n    return replacer({\n      uri,\n      value,\n      decoded: decode(value)\n    });\n  });\n}\n\n// nip28.ts\nvar nip28_exports = {};\n__export(nip28_exports, {\n  channelCreateEvent: () => channelCreateEvent,\n  channelHideMessageEvent: () => channelHideMessageEvent,\n  channelMessageEvent: () => channelMessageEvent,\n  channelMetadataEvent: () => channelMetadataEvent,\n  channelMuteUserEvent: () => channelMuteUserEvent\n});\nvar channelCreateEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelCreation,\n      tags: [...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMetadataEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMetadata,\n      tags: [[\"e\", t.channel_create_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMessageEvent = (t, privateKey) => {\n  const tags = [[\"e\", t.channel_create_event_id, t.relay_url, \"root\"]];\n  if (t.reply_to_channel_message_event_id) {\n    tags.push([\"e\", t.reply_to_channel_message_event_id, t.relay_url, \"reply\"]);\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMessage,\n      tags: [...tags, ...t.tags ?? []],\n      content: t.content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelHideMessageEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelHideMessage,\n      tags: [[\"e\", t.channel_message_event_id], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\nvar channelMuteUserEvent = (t, privateKey) => {\n  let content;\n  if (typeof t.content === \"object\") {\n    content = JSON.stringify(t.content);\n  } else if (typeof t.content === \"string\") {\n    content = t.content;\n  } else {\n    return void 0;\n  }\n  return finalizeEvent(\n    {\n      kind: ChannelMuteUser,\n      tags: [[\"p\", t.pubkey_to_mute], ...t.tags ?? []],\n      content,\n      created_at: t.created_at\n    },\n    privateKey\n  );\n};\n\n// nip30.ts\nvar nip30_exports = {};\n__export(nip30_exports, {\n  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,\n  matchAll: () => matchAll2,\n  regex: () => regex2,\n  replaceAll: () => replaceAll2\n});\nvar EMOJI_SHORTCODE_REGEX = /:(\\w+):/;\nvar regex2 = () => new RegExp(`\\\\B${EMOJI_SHORTCODE_REGEX.source}\\\\B`, \"g\");\nfunction* matchAll2(content) {\n  const matches = content.matchAll(regex2());\n  for (const match of matches) {\n    try {\n      const [shortcode, name] = match;\n      yield {\n        shortcode,\n        name,\n        start: match.index,\n        end: match.index + shortcode.length\n      };\n    } catch (_e) {\n    }\n  }\n}\nfunction replaceAll2(content, replacer) {\n  return content.replaceAll(regex2(), (shortcode, name) => {\n    return replacer({\n      shortcode,\n      name\n    });\n  });\n}\n\n// nip39.ts\nvar nip39_exports = {};\n__export(nip39_exports, {\n  useFetchImplementation: () => useFetchImplementation3,\n  validateGithub: () => validateGithub\n});\nvar _fetch3;\ntry {\n  _fetch3 = fetch;\n} catch {\n}\nfunction useFetchImplementation3(fetchImplementation) {\n  _fetch3 = fetchImplementation;\n}\nasync function validateGithub(pubkey, username, proof) {\n  try {\n    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();\n    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;\n  } catch (_) {\n    return false;\n  }\n}\n\n// nip44.ts\nvar nip44_exports = {};\n__export(nip44_exports, {\n  decrypt: () => decrypt2,\n  encrypt: () => encrypt2,\n  getConversationKey: () => getConversationKey,\n  v2: () => v2\n});\n\n\n\n\n\n\n\n\nvar minPlaintextSize = 1;\nvar maxPlaintextSize = 65535;\nfunction getConversationKey(privkeyA, pubkeyB) {\n  const sharedX = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.getSharedSecret(privkeyA, \"02\" + pubkeyB).subarray(1, 33);\n  return (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.extract)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, sharedX, \"nip44-v2\");\n}\nfunction getMessageKeys(conversationKey, nonce) {\n  const keys = (0,_noble_hashes_hkdf__WEBPACK_IMPORTED_MODULE_5__.expand)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, conversationKey, nonce, 76);\n  return {\n    chacha_key: keys.subarray(0, 32),\n    chacha_nonce: keys.subarray(32, 44),\n    hmac_key: keys.subarray(44, 76)\n  };\n}\nfunction calcPaddedLen(len) {\n  if (!Number.isSafeInteger(len) || len < 1)\n    throw new Error(\"expected positive integer\");\n  if (len <= 32)\n    return 32;\n  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;\n  const chunk = nextPower <= 256 ? 32 : nextPower / 8;\n  return chunk * (Math.floor((len - 1) / chunk) + 1);\n}\nfunction writeU16BE(num) {\n  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)\n    throw new Error(\"invalid plaintext size: must be between 1 and 65535 bytes\");\n  const arr = new Uint8Array(2);\n  new DataView(arr.buffer).setUint16(0, num, false);\n  return arr;\n}\nfunction pad(plaintext) {\n  const unpadded = utf8Encoder.encode(plaintext);\n  const unpaddedLen = unpadded.length;\n  const prefix = writeU16BE(unpaddedLen);\n  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(prefix, unpadded, suffix);\n}\nfunction unpad(padded) {\n  const unpaddedLen = new DataView(padded.buffer).getUint16(0);\n  const unpadded = padded.subarray(2, 2 + unpaddedLen);\n  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))\n    throw new Error(\"invalid padding\");\n  return utf8Decoder.decode(unpadded);\n}\nfunction hmacAad(key, message, aad) {\n  if (aad.length !== 32)\n    throw new Error(\"AAD associated data must be 32 bytes\");\n  const combined = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(aad, message);\n  return (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_6__.hmac)(_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256, key, combined);\n}\nfunction decodePayload(payload) {\n  if (typeof payload !== \"string\")\n    throw new Error(\"payload must be a valid string\");\n  const plen = payload.length;\n  if (plen < 132 || plen > 87472)\n    throw new Error(\"invalid payload length: \" + plen);\n  if (payload[0] === \"#\")\n    throw new Error(\"unknown encryption version\");\n  let data;\n  try {\n    data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(payload);\n  } catch (error) {\n    throw new Error(\"invalid base64: \" + error.message);\n  }\n  const dlen = data.length;\n  if (dlen < 99 || dlen > 65603)\n    throw new Error(\"invalid data length: \" + dlen);\n  const vers = data[0];\n  if (vers !== 2)\n    throw new Error(\"unknown encryption version \" + vers);\n  return {\n    nonce: data.subarray(1, 33),\n    ciphertext: data.subarray(33, -32),\n    mac: data.subarray(-32)\n  };\n}\nfunction encrypt2(plaintext, conversationKey, nonce = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.randomBytes)(32)) {\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const padded = pad(plaintext);\n  const ciphertext = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, padded);\n  const mac = hmacAad(hmac_key, ciphertext, nonce);\n  return _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(new Uint8Array([2]), nonce, ciphertext, mac));\n}\nfunction decrypt2(payload, conversationKey) {\n  const { nonce, ciphertext, mac } = decodePayload(payload);\n  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);\n  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);\n  if (!(0,_noble_ciphers_utils__WEBPACK_IMPORTED_MODULE_8__.equalBytes)(calculatedMac, mac))\n    throw new Error(\"invalid MAC\");\n  const padded = (0,_noble_ciphers_chacha__WEBPACK_IMPORTED_MODULE_7__.chacha20)(chacha_key, chacha_nonce, ciphertext);\n  return unpad(padded);\n}\nvar v2 = {\n  utils: {\n    getConversationKey,\n    calcPaddedLen\n  },\n  encrypt: encrypt2,\n  decrypt: decrypt2\n};\n\n// nip47.ts\nvar nip47_exports = {};\n__export(nip47_exports, {\n  makeNwcRequestEvent: () => makeNwcRequestEvent,\n  parseConnectionString: () => parseConnectionString\n});\nfunction parseConnectionString(connectionString) {\n  const { pathname, searchParams } = new URL(connectionString);\n  const pubkey = pathname;\n  const relay = searchParams.get(\"relay\");\n  const secret = searchParams.get(\"secret\");\n  if (!pubkey || !relay || !secret) {\n    throw new Error(\"invalid connection string\");\n  }\n  return { pubkey, relay, secret };\n}\nasync function makeNwcRequestEvent(pubkey, secretKey, invoice) {\n  const content = {\n    method: \"pay_invoice\",\n    params: {\n      invoice\n    }\n  };\n  const encryptedContent = await encrypt(secretKey, pubkey, JSON.stringify(content));\n  const eventTemplate = {\n    kind: NWCWalletRequest,\n    created_at: Math.round(Date.now() / 1e3),\n    content: encryptedContent,\n    tags: [[\"p\", pubkey]]\n  };\n  return finalizeEvent(eventTemplate, secretKey);\n}\n\n// nip57.ts\nvar nip57_exports = {};\n__export(nip57_exports, {\n  getZapEndpoint: () => getZapEndpoint,\n  makeZapReceipt: () => makeZapReceipt,\n  makeZapRequest: () => makeZapRequest,\n  useFetchImplementation: () => useFetchImplementation4,\n  validateZapRequest: () => validateZapRequest\n});\n\nvar _fetch4;\ntry {\n  _fetch4 = fetch;\n} catch {\n}\nfunction useFetchImplementation4(fetchImplementation) {\n  _fetch4 = fetchImplementation;\n}\nasync function getZapEndpoint(metadata) {\n  try {\n    let lnurl = \"\";\n    let { lud06, lud16 } = JSON.parse(metadata.content);\n    if (lud06) {\n      let { words } = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.decode(lud06, 1e3);\n      let data = _scure_base__WEBPACK_IMPORTED_MODULE_3__.bech32.fromWords(words);\n      lnurl = utf8Decoder.decode(data);\n    } else if (lud16) {\n      let [name, domain] = lud16.split(\"@\");\n      lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();\n    } else {\n      return null;\n    }\n    let res = await _fetch4(lnurl);\n    let body = await res.json();\n    if (body.allowsNostr && body.nostrPubkey) {\n      return body.callback;\n    }\n  } catch (err) {\n  }\n  return null;\n}\nfunction makeZapRequest({\n  profile,\n  event,\n  amount,\n  relays,\n  comment = \"\"\n}) {\n  if (!amount)\n    throw new Error(\"amount not given\");\n  if (!profile)\n    throw new Error(\"profile not given\");\n  let zr = {\n    kind: 9734,\n    created_at: Math.round(Date.now() / 1e3),\n    content: comment,\n    tags: [\n      [\"p\", profile],\n      [\"amount\", amount.toString()],\n      [\"relays\", ...relays]\n    ]\n  };\n  if (event) {\n    zr.tags.push([\"e\", event]);\n  }\n  return zr;\n}\nfunction validateZapRequest(zapRequestString) {\n  let zapRequest;\n  try {\n    zapRequest = JSON.parse(zapRequestString);\n  } catch (err) {\n    return \"Invalid zap request JSON.\";\n  }\n  if (!validateEvent(zapRequest))\n    return \"Zap request is not a valid Nostr event.\";\n  if (!verifyEvent(zapRequest))\n    return \"Invalid signature on zap request.\";\n  let p = zapRequest.tags.find(([t, v]) => t === \"p\" && v);\n  if (!p)\n    return \"Zap request doesn't have a 'p' tag.\";\n  if (!p[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'p' tag is not valid hex.\";\n  let e = zapRequest.tags.find(([t, v]) => t === \"e\" && v);\n  if (e && !e[1].match(/^[a-f0-9]{64}$/))\n    return \"Zap request 'e' tag is not valid hex.\";\n  let relays = zapRequest.tags.find(([t, v]) => t === \"relays\" && v);\n  if (!relays)\n    return \"Zap request doesn't have a 'relays' tag.\";\n  return null;\n}\nfunction makeZapReceipt({\n  zapRequest,\n  preimage,\n  bolt11,\n  paidAt\n}) {\n  let zr = JSON.parse(zapRequest);\n  let tagsFromZapRequest = zr.tags.filter(([t]) => t === \"e\" || t === \"p\" || t === \"a\");\n  let zap = {\n    kind: 9735,\n    created_at: Math.round(paidAt.getTime() / 1e3),\n    content: \"\",\n    tags: [...tagsFromZapRequest, [\"P\", zr.pubkey], [\"bolt11\", bolt11], [\"description\", zapRequest]]\n  };\n  if (preimage) {\n    zap.tags.push([\"preimage\", preimage]);\n  }\n  return zap;\n}\n\n// nip98.ts\nvar nip98_exports = {};\n__export(nip98_exports, {\n  getToken: () => getToken,\n  hashPayload: () => hashPayload,\n  unpackEventFromToken: () => unpackEventFromToken,\n  validateEvent: () => validateEvent2,\n  validateEventKind: () => validateEventKind,\n  validateEventMethodTag: () => validateEventMethodTag,\n  validateEventPayloadTag: () => validateEventPayloadTag,\n  validateEventTimestamp: () => validateEventTimestamp,\n  validateEventUrlTag: () => validateEventUrlTag,\n  validateToken: () => validateToken\n});\n\n\n\nvar _authorizationScheme = \"Nostr \";\nasync function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {\n  const event = {\n    kind: HTTPAuth,\n    tags: [\n      [\"u\", loginUrl],\n      [\"method\", httpMethod]\n    ],\n    created_at: Math.round(new Date().getTime() / 1e3),\n    content: \"\"\n  };\n  if (payload) {\n    event.tags.push([\"payload\", hashPayload(payload)]);\n  }\n  const signedEvent = await sign(event);\n  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : \"\";\n  return authorizationScheme + _scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));\n}\nasync function validateToken(token, url, method) {\n  const event = await unpackEventFromToken(token).catch((error) => {\n    throw error;\n  });\n  const valid = await validateEvent2(event, url, method).catch((error) => {\n    throw error;\n  });\n  return valid;\n}\nasync function unpackEventFromToken(token) {\n  if (!token) {\n    throw new Error(\"Missing token\");\n  }\n  token = token.replace(_authorizationScheme, \"\");\n  const eventB64 = utf8Decoder.decode(_scure_base__WEBPACK_IMPORTED_MODULE_3__.base64.decode(token));\n  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith(\"{\")) {\n    throw new Error(\"Invalid token\");\n  }\n  const event = JSON.parse(eventB64);\n  return event;\n}\nfunction validateEventTimestamp(event) {\n  if (!event.created_at) {\n    return false;\n  }\n  return Math.round(new Date().getTime() / 1e3) - event.created_at < 60;\n}\nfunction validateEventKind(event) {\n  return event.kind === HTTPAuth;\n}\nfunction validateEventUrlTag(event, url) {\n  const urlTag = event.tags.find((t) => t[0] === \"u\");\n  if (!urlTag) {\n    return false;\n  }\n  return urlTag.length > 0 && urlTag[1] === url;\n}\nfunction validateEventMethodTag(event, method) {\n  const methodTag = event.tags.find((t) => t[0] === \"method\");\n  if (!methodTag) {\n    return false;\n  }\n  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();\n}\nfunction hashPayload(payload) {\n  const hash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(JSON.stringify(payload)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(hash);\n}\nfunction validateEventPayloadTag(event, payload) {\n  const payloadTag = event.tags.find((t) => t[0] === \"payload\");\n  if (!payloadTag) {\n    return false;\n  }\n  const payloadHash = hashPayload(payload);\n  return payloadTag.length > 0 && payloadTag[1] === payloadHash;\n}\nasync function validateEvent2(event, url, method, body) {\n  if (!verifyEvent(event)) {\n    throw new Error(\"Invalid nostr event, signature invalid\");\n  }\n  if (!validateEventKind(event)) {\n    throw new Error(\"Invalid nostr event, kind invalid\");\n  }\n  if (!validateEventTimestamp(event)) {\n    throw new Error(\"Invalid nostr event, created_at timestamp invalid\");\n  }\n  if (!validateEventUrlTag(event, url)) {\n    throw new Error(\"Invalid nostr event, url tag invalid\");\n  }\n  if (!validateEventMethodTag(event, method)) {\n    throw new Error(\"Invalid nostr event, method tag invalid\");\n  }\n  if (Boolean(body) && typeof body === \"object\" && Object.keys(body).length > 0) {\n    if (!validateEventPayloadTag(event, body)) {\n      throw new Error(\"Invalid nostr event, payload tag does not match request body hash\");\n    }\n  }\n  return true;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNrRDtBQUNEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUc7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUM4Qzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVywrREFBVSxDQUFDLDREQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBVSxDQUFDLDREQUFPO0FBQ3JDO0FBQ0EsZ0JBQWdCLCtEQUFVLENBQUMsNERBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFPO0FBQzNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBTTtBQUN4QixTQUFTLCtEQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTLElBQUksSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCO0FBQzdELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGlCQUFpQjtBQUMvRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCO0FBQ3hELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsUUFBUSxhQUFhLGVBQWU7QUFDaEc7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtEQUFrRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNB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QUFDTztBQUNoQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQ0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLCtDQUFPO0FBQzdDLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0REFBTztBQUN0QixTQUFTLCtEQUFXO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1Q0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3N0ci1saW5lLWNsaWVudC8uL25vZGVfbW9kdWxlcy9ub3N0ci10b29scy9saWIvZXNtL2luZGV4LmpzPzMzYzgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gcHVyZS50c1xuaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gXCJAbm9ibGUvY3VydmVzL3NlY3AyNTZrMVwiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5cbi8vIGNvcmUudHNcbnZhciB2ZXJpZmllZFN5bWJvbCA9IFN5bWJvbChcInZlcmlmaWVkXCIpO1xudmFyIGlzUmVjb3JkID0gKG9iaikgPT4gb2JqIGluc3RhbmNlb2YgT2JqZWN0O1xuZnVuY3Rpb24gdmFsaWRhdGVFdmVudChldmVudCkge1xuICBpZiAoIWlzUmVjb3JkKGV2ZW50KSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQua2luZCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY29udGVudCAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQuY3JlYXRlZF9hdCAhPT0gXCJudW1iZXJcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgZXZlbnQucHVia2V5ICE9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFldmVudC5wdWJrZXkubWF0Y2goL15bYS1mMC05XXs2NH0kLykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoZXZlbnQudGFncykpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZXZlbnQudGFncy5sZW5ndGg7IGkyKyspIHtcbiAgICBsZXQgdGFnID0gZXZlbnQudGFnc1tpMl07XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZykpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0YWcubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdGFnW2pdID09PSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc29ydEV2ZW50cyhldmVudHMpIHtcbiAgcmV0dXJuIGV2ZW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgaWYgKGEuY3JlYXRlZF9hdCAhPT0gYi5jcmVhdGVkX2F0KSB7XG4gICAgICByZXR1cm4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0O1xuICAgIH1cbiAgICByZXR1cm4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpO1xuICB9KTtcbn1cblxuLy8gcHVyZS50c1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5cbi8vIHV0aWxzLnRzXG52YXIgdXRpbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodXRpbHNfZXhwb3J0cywge1xuICBRdWV1ZTogKCkgPT4gUXVldWUsXG4gIFF1ZXVlTm9kZTogKCkgPT4gUXVldWVOb2RlLFxuICBiaW5hcnlTZWFyY2g6ICgpID0+IGJpbmFyeVNlYXJjaCxcbiAgaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdDogKCkgPT4gaW5zZXJ0RXZlbnRJbnRvQXNjZW5kaW5nTGlzdCxcbiAgaW5zZXJ0RXZlbnRJbnRvRGVzY2VuZGluZ0xpc3Q6ICgpID0+IGluc2VydEV2ZW50SW50b0Rlc2NlbmRpbmdMaXN0LFxuICBub3JtYWxpemVVUkw6ICgpID0+IG5vcm1hbGl6ZVVSTCxcbiAgdXRmOERlY29kZXI6ICgpID0+IHV0ZjhEZWNvZGVyLFxuICB1dGY4RW5jb2RlcjogKCkgPT4gdXRmOEVuY29kZXJcbn0pO1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG52YXIgdXRmOEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVVSTCh1cmwpIHtcbiAgaWYgKHVybC5pbmRleE9mKFwiOi8vXCIpID09PSAtMSlcbiAgICB1cmwgPSBcIndzczovL1wiICsgdXJsO1xuICBsZXQgcCA9IG5ldyBVUkwodXJsKTtcbiAgcC5wYXRobmFtZSA9IHAucGF0aG5hbWUucmVwbGFjZSgvXFwvKy9nLCBcIi9cIik7XG4gIGlmIChwLnBhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSlcbiAgICBwLnBhdGhuYW1lID0gcC5wYXRobmFtZS5zbGljZSgwLCAtMSk7XG4gIGlmIChwLnBvcnQgPT09IFwiODBcIiAmJiBwLnByb3RvY29sID09PSBcIndzOlwiIHx8IHAucG9ydCA9PT0gXCI0NDNcIiAmJiBwLnByb3RvY29sID09PSBcIndzczpcIilcbiAgICBwLnBvcnQgPSBcIlwiO1xuICBwLnNlYXJjaFBhcmFtcy5zb3J0KCk7XG4gIHAuaGFzaCA9IFwiXCI7XG4gIHJldHVybiBwLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBpbnNlcnRFdmVudEludG9EZXNjZW5kaW5nTGlzdChzb3J0ZWRBcnJheSwgZXZlbnQpIHtcbiAgY29uc3QgW2lkeCwgZm91bmRdID0gYmluYXJ5U2VhcmNoKHNvcnRlZEFycmF5LCAoYikgPT4ge1xuICAgIGlmIChldmVudC5pZCA9PT0gYi5pZClcbiAgICAgIHJldHVybiAwO1xuICAgIGlmIChldmVudC5jcmVhdGVkX2F0ID09PSBiLmNyZWF0ZWRfYXQpXG4gICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIGIuY3JlYXRlZF9hdCAtIGV2ZW50LmNyZWF0ZWRfYXQ7XG4gIH0pO1xuICBpZiAoIWZvdW5kKSB7XG4gICAgc29ydGVkQXJyYXkuc3BsaWNlKGlkeCwgMCwgZXZlbnQpO1xuICB9XG4gIHJldHVybiBzb3J0ZWRBcnJheTtcbn1cbmZ1bmN0aW9uIGluc2VydEV2ZW50SW50b0FzY2VuZGluZ0xpc3Qoc29ydGVkQXJyYXksIGV2ZW50KSB7XG4gIGNvbnN0IFtpZHgsIGZvdW5kXSA9IGJpbmFyeVNlYXJjaChzb3J0ZWRBcnJheSwgKGIpID0+IHtcbiAgICBpZiAoZXZlbnQuaWQgPT09IGIuaWQpXG4gICAgICByZXR1cm4gMDtcbiAgICBpZiAoZXZlbnQuY3JlYXRlZF9hdCA9PT0gYi5jcmVhdGVkX2F0KVxuICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiBldmVudC5jcmVhdGVkX2F0IC0gYi5jcmVhdGVkX2F0O1xuICB9KTtcbiAgaWYgKCFmb3VuZCkge1xuICAgIHNvcnRlZEFycmF5LnNwbGljZShpZHgsIDAsIGV2ZW50KTtcbiAgfVxuICByZXR1cm4gc29ydGVkQXJyYXk7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2goYXJyLCBjb21wYXJlKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKHN0YXJ0ICsgZW5kKSAvIDIpO1xuICAgIGNvbnN0IGNtcCA9IGNvbXBhcmUoYXJyW21pZF0pO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHJldHVybiBbbWlkLCB0cnVlXTtcbiAgICB9XG4gICAgaWYgKGNtcCA8IDApIHtcbiAgICAgIGVuZCA9IG1pZCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gbWlkICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtzdGFydCwgZmFsc2VdO1xufVxudmFyIFF1ZXVlTm9kZSA9IGNsYXNzIHtcbiAgdmFsdWU7XG4gIG5leHQgPSBudWxsO1xuICBwcmV2ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHRoaXMudmFsdWUgPSBtZXNzYWdlO1xuICB9XG59O1xudmFyIFF1ZXVlID0gY2xhc3Mge1xuICBmaXJzdDtcbiAgbGFzdDtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgfVxuICBlbnF1ZXVlKHZhbHVlKSB7XG4gICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBRdWV1ZU5vZGUodmFsdWUpO1xuICAgIGlmICghdGhpcy5sYXN0KSB7XG4gICAgICB0aGlzLmZpcnN0ID0gbmV3Tm9kZTtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxhc3QgPT09IHRoaXMuZmlyc3QpIHtcbiAgICAgIHRoaXMubGFzdCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QucHJldiA9IHRoaXMuZmlyc3Q7XG4gICAgICB0aGlzLmZpcnN0Lm5leHQgPSBuZXdOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdOb2RlLnByZXYgPSB0aGlzLmxhc3Q7XG4gICAgICB0aGlzLmxhc3QubmV4dCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXF1ZXVlKCkge1xuICAgIGlmICghdGhpcy5maXJzdClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh0aGlzLmZpcnN0ID09PSB0aGlzLmxhc3QpIHtcbiAgICAgIGNvbnN0IHRhcmdldDIgPSB0aGlzLmZpcnN0O1xuICAgICAgdGhpcy5maXJzdCA9IG51bGw7XG4gICAgICB0aGlzLmxhc3QgPSBudWxsO1xuICAgICAgcmV0dXJuIHRhcmdldDIudmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZmlyc3Q7XG4gICAgdGhpcy5maXJzdCA9IHRhcmdldC5uZXh0O1xuICAgIHJldHVybiB0YXJnZXQudmFsdWU7XG4gIH1cbn07XG5cbi8vIHB1cmUudHNcbnZhciBKUyA9IGNsYXNzIHtcbiAgZ2VuZXJhdGVTZWNyZXRLZXkoKSB7XG4gICAgcmV0dXJuIHNjaG5vcnIudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICB9XG4gIGdldFB1YmxpY0tleShzZWNyZXRLZXkpIHtcbiAgICByZXR1cm4gYnl0ZXNUb0hleChzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpKTtcbiAgfVxuICBmaW5hbGl6ZUV2ZW50KHQsIHNlY3JldEtleSkge1xuICAgIGNvbnN0IGV2ZW50ID0gdDtcbiAgICBldmVudC5wdWJrZXkgPSBieXRlc1RvSGV4KHNjaG5vcnIuZ2V0UHVibGljS2V5KHNlY3JldEtleSkpO1xuICAgIGV2ZW50LmlkID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBldmVudC5zaWcgPSBieXRlc1RvSGV4KHNjaG5vcnIuc2lnbihnZXRFdmVudEhhc2goZXZlbnQpLCBzZWNyZXRLZXkpKTtcbiAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSB0cnVlO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxuICB2ZXJpZnlFdmVudChldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID09PSBcImJvb2xlYW5cIilcbiAgICAgIHJldHVybiBldmVudFt2ZXJpZmllZFN5bWJvbF07XG4gICAgY29uc3QgaGFzaCA9IGdldEV2ZW50SGFzaChldmVudCk7XG4gICAgaWYgKGhhc2ggIT09IGV2ZW50LmlkKSB7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbGlkID0gc2Nobm9yci52ZXJpZnkoZXZlbnQuc2lnLCBoYXNoLCBldmVudC5wdWJrZXkpO1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gdmFsaWQ7XG4gICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBldmVudFt2ZXJpZmllZFN5bWJvbF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzZXJpYWxpemVFdmVudChldnQpIHtcbiAgaWYgKCF2YWxpZGF0ZUV2ZW50KGV2dCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3Qgc2VyaWFsaXplIGV2ZW50IHdpdGggd3Jvbmcgb3IgbWlzc2luZyBwcm9wZXJ0aWVzXCIpO1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoWzAsIGV2dC5wdWJrZXksIGV2dC5jcmVhdGVkX2F0LCBldnQua2luZCwgZXZ0LnRhZ3MsIGV2dC5jb250ZW50XSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudEhhc2goZXZlbnQpIHtcbiAgbGV0IGV2ZW50SGFzaCA9IHNoYTI1Nih1dGY4RW5jb2Rlci5lbmNvZGUoc2VyaWFsaXplRXZlbnQoZXZlbnQpKSk7XG4gIHJldHVybiBieXRlc1RvSGV4KGV2ZW50SGFzaCk7XG59XG52YXIgaSA9IG5ldyBKUygpO1xudmFyIGdlbmVyYXRlU2VjcmV0S2V5ID0gaS5nZW5lcmF0ZVNlY3JldEtleTtcbnZhciBnZXRQdWJsaWNLZXkgPSBpLmdldFB1YmxpY0tleTtcbnZhciBmaW5hbGl6ZUV2ZW50ID0gaS5maW5hbGl6ZUV2ZW50O1xudmFyIHZlcmlmeUV2ZW50ID0gaS52ZXJpZnlFdmVudDtcblxuLy8ga2luZHMudHNcbnZhciBraW5kc19leHBvcnRzID0ge307XG5fX2V4cG9ydChraW5kc19leHBvcnRzLCB7XG4gIEFwcGxpY2F0aW9uOiAoKSA9PiBBcHBsaWNhdGlvbixcbiAgQmFkZ2VBd2FyZDogKCkgPT4gQmFkZ2VBd2FyZCxcbiAgQmFkZ2VEZWZpbml0aW9uOiAoKSA9PiBCYWRnZURlZmluaXRpb24sXG4gIEJsb2NrZWRSZWxheXNMaXN0OiAoKSA9PiBCbG9ja2VkUmVsYXlzTGlzdCxcbiAgQm9va21hcmtMaXN0OiAoKSA9PiBCb29rbWFya0xpc3QsXG4gIEJvb2ttYXJrc2V0czogKCkgPT4gQm9va21hcmtzZXRzLFxuICBDYWxlbmRhcjogKCkgPT4gQ2FsZW5kYXIsXG4gIENhbGVuZGFyRXZlbnRSU1ZQOiAoKSA9PiBDYWxlbmRhckV2ZW50UlNWUCxcbiAgQ2hhbm5lbENyZWF0aW9uOiAoKSA9PiBDaGFubmVsQ3JlYXRpb24sXG4gIENoYW5uZWxIaWRlTWVzc2FnZTogKCkgPT4gQ2hhbm5lbEhpZGVNZXNzYWdlLFxuICBDaGFubmVsTWVzc2FnZTogKCkgPT4gQ2hhbm5lbE1lc3NhZ2UsXG4gIENoYW5uZWxNZXRhZGF0YTogKCkgPT4gQ2hhbm5lbE1ldGFkYXRhLFxuICBDaGFubmVsTXV0ZVVzZXI6ICgpID0+IENoYW5uZWxNdXRlVXNlcixcbiAgQ2xhc3NpZmllZExpc3Rpbmc6ICgpID0+IENsYXNzaWZpZWRMaXN0aW5nLFxuICBDbGllbnRBdXRoOiAoKSA9PiBDbGllbnRBdXRoLFxuICBDb21tdW5pdGllc0xpc3Q6ICgpID0+IENvbW11bml0aWVzTGlzdCxcbiAgQ29tbXVuaXR5RGVmaW5pdGlvbjogKCkgPT4gQ29tbXVuaXR5RGVmaW5pdGlvbixcbiAgQ29tbXVuaXR5UG9zdEFwcHJvdmFsOiAoKSA9PiBDb21tdW5pdHlQb3N0QXBwcm92YWwsXG4gIENvbnRhY3RzOiAoKSA9PiBDb250YWN0cyxcbiAgQ3JlYXRlT3JVcGRhdGVQcm9kdWN0OiAoKSA9PiBDcmVhdGVPclVwZGF0ZVByb2R1Y3QsXG4gIENyZWF0ZU9yVXBkYXRlU3RhbGw6ICgpID0+IENyZWF0ZU9yVXBkYXRlU3RhbGwsXG4gIEN1cmF0aW9uc2V0czogKCkgPT4gQ3VyYXRpb25zZXRzLFxuICBEYXRlOiAoKSA9PiBEYXRlMixcbiAgRHJhZnRDbGFzc2lmaWVkTGlzdGluZzogKCkgPT4gRHJhZnRDbGFzc2lmaWVkTGlzdGluZyxcbiAgRHJhZnRMb25nOiAoKSA9PiBEcmFmdExvbmcsXG4gIEVtb2ppc2V0czogKCkgPT4gRW1vamlzZXRzLFxuICBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlOiAoKSA9PiBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlLFxuICBFbmNyeXB0ZWREaXJlY3RNZXNzYWdlczogKCkgPT4gRW5jcnlwdGVkRGlyZWN0TWVzc2FnZXMsXG4gIEV2ZW50RGVsZXRpb246ICgpID0+IEV2ZW50RGVsZXRpb24sXG4gIEZpbGVNZXRhZGF0YTogKCkgPT4gRmlsZU1ldGFkYXRhLFxuICBGaWxlU2VydmVyUHJlZmVyZW5jZTogKCkgPT4gRmlsZVNlcnZlclByZWZlcmVuY2UsXG4gIEZvbGxvd3NldHM6ICgpID0+IEZvbGxvd3NldHMsXG4gIEdlbmVyaWNSZXBvc3Q6ICgpID0+IEdlbmVyaWNSZXBvc3QsXG4gIEdlbmVyaWNsaXN0czogKCkgPT4gR2VuZXJpY2xpc3RzLFxuICBIVFRQQXV0aDogKCkgPT4gSFRUUEF1dGgsXG4gIEhhbmRsZXJpbmZvcm1hdGlvbjogKCkgPT4gSGFuZGxlcmluZm9ybWF0aW9uLFxuICBIYW5kbGVycmVjb21tZW5kYXRpb246ICgpID0+IEhhbmRsZXJyZWNvbW1lbmRhdGlvbixcbiAgSGlnaGxpZ2h0czogKCkgPT4gSGlnaGxpZ2h0cyxcbiAgSW50ZXJlc3RzTGlzdDogKCkgPT4gSW50ZXJlc3RzTGlzdCxcbiAgSW50ZXJlc3RzZXRzOiAoKSA9PiBJbnRlcmVzdHNldHMsXG4gIEpvYkZlZWRiYWNrOiAoKSA9PiBKb2JGZWVkYmFjayxcbiAgSm9iUmVxdWVzdDogKCkgPT4gSm9iUmVxdWVzdCxcbiAgSm9iUmVzdWx0OiAoKSA9PiBKb2JSZXN1bHQsXG4gIExhYmVsOiAoKSA9PiBMYWJlbCxcbiAgTGlnaHRuaW5nUHViUlBDOiAoKSA9PiBMaWdodG5pbmdQdWJSUEMsXG4gIExpdmVDaGF0TWVzc2FnZTogKCkgPT4gTGl2ZUNoYXRNZXNzYWdlLFxuICBMaXZlRXZlbnQ6ICgpID0+IExpdmVFdmVudCxcbiAgTG9uZ0Zvcm1BcnRpY2xlOiAoKSA9PiBMb25nRm9ybUFydGljbGUsXG4gIE1ldGFkYXRhOiAoKSA9PiBNZXRhZGF0YSxcbiAgTXV0ZWxpc3Q6ICgpID0+IE11dGVsaXN0LFxuICBOV0NXYWxsZXRJbmZvOiAoKSA9PiBOV0NXYWxsZXRJbmZvLFxuICBOV0NXYWxsZXRSZXF1ZXN0OiAoKSA9PiBOV0NXYWxsZXRSZXF1ZXN0LFxuICBOV0NXYWxsZXRSZXNwb25zZTogKCkgPT4gTldDV2FsbGV0UmVzcG9uc2UsXG4gIE5vc3RyQ29ubmVjdDogKCkgPT4gTm9zdHJDb25uZWN0LFxuICBPcGVuVGltZXN0YW1wczogKCkgPT4gT3BlblRpbWVzdGFtcHMsXG4gIFBpbmxpc3Q6ICgpID0+IFBpbmxpc3QsXG4gIFByb2JsZW1UcmFja2VyOiAoKSA9PiBQcm9ibGVtVHJhY2tlcixcbiAgUHJvZmlsZUJhZGdlczogKCkgPT4gUHJvZmlsZUJhZGdlcyxcbiAgUHVibGljQ2hhdHNMaXN0OiAoKSA9PiBQdWJsaWNDaGF0c0xpc3QsXG4gIFJlYWN0aW9uOiAoKSA9PiBSZWFjdGlvbixcbiAgUmVjb21tZW5kUmVsYXk6ICgpID0+IFJlY29tbWVuZFJlbGF5LFxuICBSZWxheUxpc3Q6ICgpID0+IFJlbGF5TGlzdCxcbiAgUmVsYXlzZXRzOiAoKSA9PiBSZWxheXNldHMsXG4gIFJlcG9ydDogKCkgPT4gUmVwb3J0LFxuICBSZXBvcnRpbmc6ICgpID0+IFJlcG9ydGluZyxcbiAgUmVwb3N0OiAoKSA9PiBSZXBvc3QsXG4gIFNlYXJjaFJlbGF5c0xpc3Q6ICgpID0+IFNlYXJjaFJlbGF5c0xpc3QsXG4gIFNob3J0VGV4dE5vdGU6ICgpID0+IFNob3J0VGV4dE5vdGUsXG4gIFRpbWU6ICgpID0+IFRpbWUsXG4gIFVzZXJFbW9qaUxpc3Q6ICgpID0+IFVzZXJFbW9qaUxpc3QsXG4gIFVzZXJTdGF0dXNlczogKCkgPT4gVXNlclN0YXR1c2VzLFxuICBaYXA6ICgpID0+IFphcCxcbiAgWmFwR29hbDogKCkgPT4gWmFwR29hbCxcbiAgWmFwUmVxdWVzdDogKCkgPT4gWmFwUmVxdWVzdCxcbiAgY2xhc3NpZnlLaW5kOiAoKSA9PiBjbGFzc2lmeUtpbmQsXG4gIGlzRXBoZW1lcmFsS2luZDogKCkgPT4gaXNFcGhlbWVyYWxLaW5kLFxuICBpc1BhcmFtZXRlcml6ZWRSZXBsYWNlYWJsZUtpbmQ6ICgpID0+IGlzUGFyYW1ldGVyaXplZFJlcGxhY2VhYmxlS2luZCxcbiAgaXNSZWd1bGFyS2luZDogKCkgPT4gaXNSZWd1bGFyS2luZCxcbiAgaXNSZXBsYWNlYWJsZUtpbmQ6ICgpID0+IGlzUmVwbGFjZWFibGVLaW5kXG59KTtcbmZ1bmN0aW9uIGlzUmVndWxhcktpbmQoa2luZCkge1xuICByZXR1cm4gMWUzIDw9IGtpbmQgJiYga2luZCA8IDFlNCB8fCBbMSwgMiwgNCwgNSwgNiwgNywgOCwgMTYsIDQwLCA0MSwgNDIsIDQzLCA0NF0uaW5jbHVkZXMoa2luZCk7XG59XG5mdW5jdGlvbiBpc1JlcGxhY2VhYmxlS2luZChraW5kKSB7XG4gIHJldHVybiBbMCwgM10uaW5jbHVkZXMoa2luZCkgfHwgMWU0IDw9IGtpbmQgJiYga2luZCA8IDJlNDtcbn1cbmZ1bmN0aW9uIGlzRXBoZW1lcmFsS2luZChraW5kKSB7XG4gIHJldHVybiAyZTQgPD0ga2luZCAmJiBraW5kIDwgM2U0O1xufVxuZnVuY3Rpb24gaXNQYXJhbWV0ZXJpemVkUmVwbGFjZWFibGVLaW5kKGtpbmQpIHtcbiAgcmV0dXJuIDNlNCA8PSBraW5kICYmIGtpbmQgPCA0ZTQ7XG59XG5mdW5jdGlvbiBjbGFzc2lmeUtpbmQoa2luZCkge1xuICBpZiAoaXNSZWd1bGFyS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJyZWd1bGFyXCI7XG4gIGlmIChpc1JlcGxhY2VhYmxlS2luZChraW5kKSlcbiAgICByZXR1cm4gXCJyZXBsYWNlYWJsZVwiO1xuICBpZiAoaXNFcGhlbWVyYWxLaW5kKGtpbmQpKVxuICAgIHJldHVybiBcImVwaGVtZXJhbFwiO1xuICBpZiAoaXNQYXJhbWV0ZXJpemVkUmVwbGFjZWFibGVLaW5kKGtpbmQpKVxuICAgIHJldHVybiBcInBhcmFtZXRlcml6ZWRcIjtcbiAgcmV0dXJuIFwidW5rbm93blwiO1xufVxudmFyIE1ldGFkYXRhID0gMDtcbnZhciBTaG9ydFRleHROb3RlID0gMTtcbnZhciBSZWNvbW1lbmRSZWxheSA9IDI7XG52YXIgQ29udGFjdHMgPSAzO1xudmFyIEVuY3J5cHRlZERpcmVjdE1lc3NhZ2UgPSA0O1xudmFyIEVuY3J5cHRlZERpcmVjdE1lc3NhZ2VzID0gNDtcbnZhciBFdmVudERlbGV0aW9uID0gNTtcbnZhciBSZXBvc3QgPSA2O1xudmFyIFJlYWN0aW9uID0gNztcbnZhciBCYWRnZUF3YXJkID0gODtcbnZhciBHZW5lcmljUmVwb3N0ID0gMTY7XG52YXIgQ2hhbm5lbENyZWF0aW9uID0gNDA7XG52YXIgQ2hhbm5lbE1ldGFkYXRhID0gNDE7XG52YXIgQ2hhbm5lbE1lc3NhZ2UgPSA0MjtcbnZhciBDaGFubmVsSGlkZU1lc3NhZ2UgPSA0MztcbnZhciBDaGFubmVsTXV0ZVVzZXIgPSA0NDtcbnZhciBPcGVuVGltZXN0YW1wcyA9IDEwNDA7XG52YXIgRmlsZU1ldGFkYXRhID0gMTA2MztcbnZhciBMaXZlQ2hhdE1lc3NhZ2UgPSAxMzExO1xudmFyIFByb2JsZW1UcmFja2VyID0gMTk3MTtcbnZhciBSZXBvcnQgPSAxOTg0O1xudmFyIFJlcG9ydGluZyA9IDE5ODQ7XG52YXIgTGFiZWwgPSAxOTg1O1xudmFyIENvbW11bml0eVBvc3RBcHByb3ZhbCA9IDQ1NTA7XG52YXIgSm9iUmVxdWVzdCA9IDU5OTk7XG52YXIgSm9iUmVzdWx0ID0gNjk5OTtcbnZhciBKb2JGZWVkYmFjayA9IDdlMztcbnZhciBaYXBHb2FsID0gOTA0MTtcbnZhciBaYXBSZXF1ZXN0ID0gOTczNDtcbnZhciBaYXAgPSA5NzM1O1xudmFyIEhpZ2hsaWdodHMgPSA5ODAyO1xudmFyIE11dGVsaXN0ID0gMWU0O1xudmFyIFBpbmxpc3QgPSAxMDAwMTtcbnZhciBSZWxheUxpc3QgPSAxMDAwMjtcbnZhciBCb29rbWFya0xpc3QgPSAxMDAwMztcbnZhciBDb21tdW5pdGllc0xpc3QgPSAxMDAwNDtcbnZhciBQdWJsaWNDaGF0c0xpc3QgPSAxMDAwNTtcbnZhciBCbG9ja2VkUmVsYXlzTGlzdCA9IDEwMDA2O1xudmFyIFNlYXJjaFJlbGF5c0xpc3QgPSAxMDAwNztcbnZhciBJbnRlcmVzdHNMaXN0ID0gMTAwMTU7XG52YXIgVXNlckVtb2ppTGlzdCA9IDEwMDMwO1xudmFyIEZpbGVTZXJ2ZXJQcmVmZXJlbmNlID0gMTAwOTY7XG52YXIgTldDV2FsbGV0SW5mbyA9IDEzMTk0O1xudmFyIExpZ2h0bmluZ1B1YlJQQyA9IDIxZTM7XG52YXIgQ2xpZW50QXV0aCA9IDIyMjQyO1xudmFyIE5XQ1dhbGxldFJlcXVlc3QgPSAyMzE5NDtcbnZhciBOV0NXYWxsZXRSZXNwb25zZSA9IDIzMTk1O1xudmFyIE5vc3RyQ29ubmVjdCA9IDI0MTMzO1xudmFyIEhUVFBBdXRoID0gMjcyMzU7XG52YXIgRm9sbG93c2V0cyA9IDNlNDtcbnZhciBHZW5lcmljbGlzdHMgPSAzMDAwMTtcbnZhciBSZWxheXNldHMgPSAzMDAwMjtcbnZhciBCb29rbWFya3NldHMgPSAzMDAwMztcbnZhciBDdXJhdGlvbnNldHMgPSAzMDAwNDtcbnZhciBQcm9maWxlQmFkZ2VzID0gMzAwMDg7XG52YXIgQmFkZ2VEZWZpbml0aW9uID0gMzAwMDk7XG52YXIgSW50ZXJlc3RzZXRzID0gMzAwMTU7XG52YXIgQ3JlYXRlT3JVcGRhdGVTdGFsbCA9IDMwMDE3O1xudmFyIENyZWF0ZU9yVXBkYXRlUHJvZHVjdCA9IDMwMDE4O1xudmFyIExvbmdGb3JtQXJ0aWNsZSA9IDMwMDIzO1xudmFyIERyYWZ0TG9uZyA9IDMwMDI0O1xudmFyIEVtb2ppc2V0cyA9IDMwMDMwO1xudmFyIEFwcGxpY2F0aW9uID0gMzAwNzg7XG52YXIgTGl2ZUV2ZW50ID0gMzAzMTE7XG52YXIgVXNlclN0YXR1c2VzID0gMzAzMTU7XG52YXIgQ2xhc3NpZmllZExpc3RpbmcgPSAzMDQwMjtcbnZhciBEcmFmdENsYXNzaWZpZWRMaXN0aW5nID0gMzA0MDM7XG52YXIgRGF0ZTIgPSAzMTkyMjtcbnZhciBUaW1lID0gMzE5MjM7XG52YXIgQ2FsZW5kYXIgPSAzMTkyNDtcbnZhciBDYWxlbmRhckV2ZW50UlNWUCA9IDMxOTI1O1xudmFyIEhhbmRsZXJyZWNvbW1lbmRhdGlvbiA9IDMxOTg5O1xudmFyIEhhbmRsZXJpbmZvcm1hdGlvbiA9IDMxOTkwO1xudmFyIENvbW11bml0eURlZmluaXRpb24gPSAzNDU1MDtcblxuLy8gZmlsdGVyLnRzXG5mdW5jdGlvbiBtYXRjaEZpbHRlcihmaWx0ZXIsIGV2ZW50KSB7XG4gIGlmIChmaWx0ZXIuaWRzICYmIGZpbHRlci5pZHMuaW5kZXhPZihldmVudC5pZCkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWx0ZXIua2luZHMgJiYgZmlsdGVyLmtpbmRzLmluZGV4T2YoZXZlbnQua2luZCkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChmaWx0ZXIuYXV0aG9ycyAmJiBmaWx0ZXIuYXV0aG9ycy5pbmRleE9mKGV2ZW50LnB1YmtleSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGYgaW4gZmlsdGVyKSB7XG4gICAgaWYgKGZbMF0gPT09IFwiI1wiKSB7XG4gICAgICBsZXQgdGFnTmFtZSA9IGYuc2xpY2UoMSk7XG4gICAgICBsZXQgdmFsdWVzID0gZmlsdGVyW2AjJHt0YWdOYW1lfWBdO1xuICAgICAgaWYgKHZhbHVlcyAmJiAhZXZlbnQudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IGYuc2xpY2UoMSkgJiYgdmFsdWVzLmluZGV4T2YodikgIT09IC0xKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoZmlsdGVyLnNpbmNlICYmIGV2ZW50LmNyZWF0ZWRfYXQgPCBmaWx0ZXIuc2luY2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmlsdGVyLnVudGlsICYmIGV2ZW50LmNyZWF0ZWRfYXQgPiBmaWx0ZXIudW50aWwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hdGNoRmlsdGVycyhmaWx0ZXJzLCBldmVudCkge1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZmlsdGVycy5sZW5ndGg7IGkyKyspIHtcbiAgICBpZiAobWF0Y2hGaWx0ZXIoZmlsdGVyc1tpMl0sIGV2ZW50KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIG1lcmdlRmlsdGVycyguLi5maWx0ZXJzKSB7XG4gIGxldCByZXN1bHQgPSB7fTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGZpbHRlcnMubGVuZ3RoOyBpMisrKSB7XG4gICAgbGV0IGZpbHRlciA9IGZpbHRlcnNbaTJdO1xuICAgIE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZm9yRWFjaCgoW3Byb3BlcnR5LCB2YWx1ZXNdKSA9PiB7XG4gICAgICBpZiAocHJvcGVydHkgPT09IFwia2luZHNcIiB8fCBwcm9wZXJ0eSA9PT0gXCJpZHNcIiB8fCBwcm9wZXJ0eSA9PT0gXCJhdXRob3JzXCIgfHwgcHJvcGVydHlbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSByZXN1bHRbcHJvcGVydHldIHx8IFtdO1xuICAgICAgICBmb3IgKGxldCB2ID0gMDsgdiA8IHZhbHVlcy5sZW5ndGg7IHYrKykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHZhbHVlc1t2XTtcbiAgICAgICAgICBpZiAoIXJlc3VsdFtwcm9wZXJ0eV0uaW5jbHVkZXModmFsdWUpKVxuICAgICAgICAgICAgcmVzdWx0W3Byb3BlcnR5XS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChmaWx0ZXIubGltaXQgJiYgKCFyZXN1bHQubGltaXQgfHwgZmlsdGVyLmxpbWl0ID4gcmVzdWx0LmxpbWl0KSlcbiAgICAgIHJlc3VsdC5saW1pdCA9IGZpbHRlci5saW1pdDtcbiAgICBpZiAoZmlsdGVyLnVudGlsICYmICghcmVzdWx0LnVudGlsIHx8IGZpbHRlci51bnRpbCA+IHJlc3VsdC51bnRpbCkpXG4gICAgICByZXN1bHQudW50aWwgPSBmaWx0ZXIudW50aWw7XG4gICAgaWYgKGZpbHRlci5zaW5jZSAmJiAoIXJlc3VsdC5zaW5jZSB8fCBmaWx0ZXIuc2luY2UgPCByZXN1bHQuc2luY2UpKVxuICAgICAgcmVzdWx0LnNpbmNlID0gZmlsdGVyLnNpbmNlO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRGaWx0ZXJMaW1pdChmaWx0ZXIpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgIWZpbHRlci5pZHMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBpZiAoZmlsdGVyLmtpbmRzICYmICFmaWx0ZXIua2luZHMubGVuZ3RoKVxuICAgIHJldHVybiAwO1xuICBpZiAoZmlsdGVyLmF1dGhvcnMgJiYgIWZpbHRlci5hdXRob3JzLmxlbmd0aClcbiAgICByZXR1cm4gMDtcbiAgcmV0dXJuIE1hdGgubWluKFxuICAgIE1hdGgubWF4KDAsIGZpbHRlci5saW1pdCA/PyBJbmZpbml0eSksXG4gICAgZmlsdGVyLmlkcz8ubGVuZ3RoID8/IEluZmluaXR5LFxuICAgIGZpbHRlci5hdXRob3JzPy5sZW5ndGggJiYgZmlsdGVyLmtpbmRzPy5ldmVyeSgoa2luZCkgPT4gaXNSZXBsYWNlYWJsZUtpbmQoa2luZCkpID8gZmlsdGVyLmF1dGhvcnMubGVuZ3RoICogZmlsdGVyLmtpbmRzLmxlbmd0aCA6IEluZmluaXR5XG4gICk7XG59XG5cbi8vIGZha2Vqc29uLnRzXG52YXIgZmFrZWpzb25fZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZmFrZWpzb25fZXhwb3J0cywge1xuICBnZXRIZXg2NDogKCkgPT4gZ2V0SGV4NjQsXG4gIGdldEludDogKCkgPT4gZ2V0SW50LFxuICBnZXRTdWJzY3JpcHRpb25JZDogKCkgPT4gZ2V0U3Vic2NyaXB0aW9uSWQsXG4gIG1hdGNoRXZlbnRJZDogKCkgPT4gbWF0Y2hFdmVudElkLFxuICBtYXRjaEV2ZW50S2luZDogKCkgPT4gbWF0Y2hFdmVudEtpbmQsXG4gIG1hdGNoRXZlbnRQdWJrZXk6ICgpID0+IG1hdGNoRXZlbnRQdWJrZXlcbn0pO1xuZnVuY3Rpb24gZ2V0SGV4NjQoanNvbiwgZmllbGQpIHtcbiAgbGV0IGxlbiA9IGZpZWxkLmxlbmd0aCArIDM7XG4gIGxldCBpZHggPSBqc29uLmluZGV4T2YoYFwiJHtmaWVsZH1cIjpgKSArIGxlbjtcbiAgbGV0IHMgPSBqc29uLnNsaWNlKGlkeCkuaW5kZXhPZihgXCJgKSArIGlkeCArIDE7XG4gIHJldHVybiBqc29uLnNsaWNlKHMsIHMgKyA2NCk7XG59XG5mdW5jdGlvbiBnZXRJbnQoanNvbiwgZmllbGQpIHtcbiAgbGV0IGxlbiA9IGZpZWxkLmxlbmd0aDtcbiAgbGV0IGlkeCA9IGpzb24uaW5kZXhPZihgXCIke2ZpZWxkfVwiOmApICsgbGVuICsgMztcbiAgbGV0IHNsaWNlZCA9IGpzb24uc2xpY2UoaWR4KTtcbiAgbGV0IGVuZCA9IE1hdGgubWluKHNsaWNlZC5pbmRleE9mKFwiLFwiKSwgc2xpY2VkLmluZGV4T2YoXCJ9XCIpKTtcbiAgcmV0dXJuIHBhcnNlSW50KHNsaWNlZC5zbGljZSgwLCBlbmQpLCAxMCk7XG59XG5mdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25JZChqc29uKSB7XG4gIGxldCBpZHggPSBqc29uLnNsaWNlKDAsIDIyKS5pbmRleE9mKGBcIkVWRU5UXCJgKTtcbiAgaWYgKGlkeCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBwc3RhcnQgPSBqc29uLnNsaWNlKGlkeCArIDcgKyAxKS5pbmRleE9mKGBcImApO1xuICBpZiAocHN0YXJ0ID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHN0YXJ0ID0gaWR4ICsgNyArIDEgKyBwc3RhcnQ7XG4gIGxldCBwZW5kID0ganNvbi5zbGljZShzdGFydCArIDEsIDgwKS5pbmRleE9mKGBcImApO1xuICBpZiAocGVuZCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBlbmQgPSBzdGFydCArIDEgKyBwZW5kO1xuICByZXR1cm4ganNvbi5zbGljZShzdGFydCArIDEsIGVuZCk7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50SWQoanNvbiwgaWQpIHtcbiAgcmV0dXJuIGlkID09PSBnZXRIZXg2NChqc29uLCBcImlkXCIpO1xufVxuZnVuY3Rpb24gbWF0Y2hFdmVudFB1YmtleShqc29uLCBwdWJrZXkpIHtcbiAgcmV0dXJuIHB1YmtleSA9PT0gZ2V0SGV4NjQoanNvbiwgXCJwdWJrZXlcIik7XG59XG5mdW5jdGlvbiBtYXRjaEV2ZW50S2luZChqc29uLCBraW5kKSB7XG4gIHJldHVybiBraW5kID09PSBnZXRJbnQoanNvbiwgXCJraW5kXCIpO1xufVxuXG4vLyBuaXA0Mi50c1xudmFyIG5pcDQyX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDQyX2V4cG9ydHMsIHtcbiAgbWFrZUF1dGhFdmVudDogKCkgPT4gbWFrZUF1dGhFdmVudFxufSk7XG5mdW5jdGlvbiBtYWtlQXV0aEV2ZW50KHJlbGF5VVJMLCBjaGFsbGVuZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBDbGllbnRBdXRoLFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgdGFnczogW1xuICAgICAgW1wicmVsYXlcIiwgcmVsYXlVUkxdLFxuICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICBdLFxuICAgIGNvbnRlbnQ6IFwiXCJcbiAgfTtcbn1cblxuLy8gaGVscGVycy50c1xuYXN5bmMgZnVuY3Rpb24geWllbGRUaHJlYWQoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGNoID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNoLnBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgY2gucG9ydDEuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgY2gucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgY2gucG9ydDEuc3RhcnQoKTtcbiAgfSk7XG59XG52YXIgYWx3YXlzVHJ1ZSA9ICh0KSA9PiB7XG4gIHRbdmVyaWZpZWRTeW1ib2xdID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBhYnN0cmFjdC1yZWxheS50c1xudmFyIEFic3RyYWN0UmVsYXkgPSBjbGFzcyB7XG4gIHVybDtcbiAgX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICBvbmNsb3NlID0gbnVsbDtcbiAgb25ub3RpY2UgPSAobXNnKSA9PiBjb25zb2xlLmRlYnVnKGBOT1RJQ0UgZnJvbSAke3RoaXMudXJsfTogJHttc2d9YCk7XG4gIF9vbmF1dGggPSBudWxsO1xuICBiYXNlRW9zZVRpbWVvdXQgPSA0NDAwO1xuICBjb25uZWN0aW9uVGltZW91dCA9IDQ0MDA7XG4gIG9wZW5TdWJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29ubmVjdGlvblRpbWVvdXRIYW5kbGU7XG4gIGNvbm5lY3Rpb25Qcm9taXNlO1xuICBvcGVuQ291bnRSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG9wZW5FdmVudFB1Ymxpc2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHdzO1xuICBpbmNvbWluZ01lc3NhZ2VRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICBxdWV1ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgY2hhbGxlbmdlO1xuICBzZXJpYWwgPSAwO1xuICB2ZXJpZnlFdmVudDtcbiAgX1dlYlNvY2tldDtcbiAgY29uc3RydWN0b3IodXJsLCBvcHRzKSB7XG4gICAgdGhpcy51cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICB0aGlzLnZlcmlmeUV2ZW50ID0gb3B0cy52ZXJpZnlFdmVudDtcbiAgICB0aGlzLl9XZWJTb2NrZXQgPSBvcHRzLndlYnNvY2tldEltcGxlbWVudGF0aW9uIHx8IFdlYlNvY2tldDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY29ubmVjdCh1cmwsIG9wdHMpIHtcbiAgICBjb25zdCByZWxheSA9IG5ldyBBYnN0cmFjdFJlbGF5KHVybCwgb3B0cyk7XG4gICAgYXdhaXQgcmVsYXkuY29ubmVjdCgpO1xuICAgIHJldHVybiByZWxheTtcbiAgfVxuICBjbG9zZUFsbFN1YnNjcmlwdGlvbnMocmVhc29uKSB7XG4gICAgZm9yIChsZXQgW18sIHN1Yl0gb2YgdGhpcy5vcGVuU3Vicykge1xuICAgICAgc3ViLmNsb3NlKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMub3BlblN1YnMuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBbXywgZXBdIG9mIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzKSB7XG4gICAgICBlcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgIH1cbiAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5jbGVhcigpO1xuICAgIGZvciAobGV0IFtfLCBjcl0gb2YgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cykge1xuICAgICAgY3IucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5jbGVhcigpO1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZDtcbiAgfVxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKVxuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gICAgdGhpcy5jaGFsbGVuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KFwiY29ubmVjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICB9LCB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgdGhpcy5fV2ViU29ja2V0KHRoaXMudXJsKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25lcnJvciA9IChldikgPT4ge1xuICAgICAgICByZWplY3QoZXYubWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGVycm9yZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9uY2xvc2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5fb25tZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gIH1cbiAgYXN5bmMgcnVuUXVldWUoKSB7XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSB0cnVlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IHRoaXMuaGFuZGxlTmV4dCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXdhaXQgeWllbGRUaHJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgfVxuICBoYW5kbGVOZXh0KCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmluY29taW5nTWVzc2FnZVF1ZXVlLmRlcXVldWUoKTtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViaWQgPSBnZXRTdWJzY3JpcHRpb25JZChqc29uKTtcbiAgICBpZiAoc3ViaWQpIHtcbiAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoc3ViaWQpO1xuICAgICAgaWYgKCFzbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IGdldEhleDY0KGpzb24sIFwiaWRcIik7XG4gICAgICBjb25zdCBhbHJlYWR5SGF2ZSA9IHNvLmFscmVhZHlIYXZlRXZlbnQ/LihpZCk7XG4gICAgICBzby5yZWNlaXZlZEV2ZW50Py4odGhpcywgaWQpO1xuICAgICAgaWYgKGFscmVhZHlIYXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgIHN3aXRjaCAoZGF0YVswXSkge1xuICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoZGF0YVsxXSk7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBkYXRhWzJdO1xuICAgICAgICAgIGlmICh0aGlzLnZlcmlmeUV2ZW50KGV2ZW50KSAmJiBtYXRjaEZpbHRlcnMoc28uZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgICAgICBzby5vbmV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDT1VOVFwiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IGNyID0gdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjcikge1xuICAgICAgICAgICAgY3IucmVzb2x2ZShwYXlsb2FkLmNvdW50KTtcbiAgICAgICAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJFT1NFXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGRhdGFbMV0pO1xuICAgICAgICAgIGlmICghc28pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc28ucmVjZWl2ZWRFb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IG9rID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBkYXRhWzNdO1xuICAgICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAob2spXG4gICAgICAgICAgICBlcC5yZXNvbHZlKHJlYXNvbik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZXAucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5kZWxldGUoaWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiQ0xPU0VEXCI6IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGRhdGFbMV07XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBzby5jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgIHNvLmNsb3NlKGRhdGFbMl0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiTk9USUNFXCI6XG4gICAgICAgICAgdGhpcy5vbm5vdGljZShkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJBVVRIXCI6IHtcbiAgICAgICAgICB0aGlzLmNoYWxsZW5nZSA9IGRhdGFbMV07XG4gICAgICAgICAgdGhpcy5fb25hdXRoPy4oZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGFzeW5jIHNlbmQobWVzc2FnZSkge1xuICAgIGlmICghdGhpcy5jb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNlbmRpbmcgb24gY2xvc2VkIGNvbm5lY3Rpb25cIik7XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMud3M/LnNlbmQobWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYXV0aChzaWduQXV0aEV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmNoYWxsZW5nZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHBlcmZvcm0gYXV0aCwgbm8gY2hhbGxlbmdlIHdhcyByZWNlaXZlZFwiKTtcbiAgICBjb25zdCBldnQgPSBhd2FpdCBzaWduQXV0aEV2ZW50KG1ha2VBdXRoRXZlbnQodGhpcy51cmwsIHRoaXMuY2hhbGxlbmdlKSk7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2dC5pZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJBVVRIXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2dCkgKyBcIl1cIik7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBhc3luYyBwdWJsaXNoKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2ZW50LmlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkVWRU5UXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2ZW50KSArIFwiXVwiKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGFzeW5jIGNvdW50KGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXM/LmlkIHx8IFwiY291bnQ6XCIgKyB0aGlzLnNlcmlhbDtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJDT1VOVFwiLFwiJyArIGlkICsgJ1wiLCcgKyBKU09OLnN0cmluZ2lmeShmaWx0ZXJzKS5zdWJzdHJpbmcoMSkpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgc3Vic2NyaWJlKGZpbHRlcnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMucHJlcGFyZVN1YnNjcmlwdGlvbihmaWx0ZXJzLCBwYXJhbXMpO1xuICAgIHN1YnNjcmlwdGlvbi5maXJlKCk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuICBwcmVwYXJlU3Vic2NyaXB0aW9uKGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXMuaWQgfHwgXCJzdWI6XCIgKyB0aGlzLnNlcmlhbDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMsIGlkLCBmaWx0ZXJzLCBwYXJhbXMpO1xuICAgIHRoaXMub3BlblN1YnMuc2V0KGlkLCBzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZCBieSB1c1wiKTtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLndzPy5jbG9zZSgpO1xuICB9XG4gIF9vbm1lc3NhZ2UoZXYpIHtcbiAgICB0aGlzLmluY29taW5nTWVzc2FnZVF1ZXVlLmVucXVldWUoZXYuZGF0YSk7XG4gICAgaWYgKCF0aGlzLnF1ZXVlUnVubmluZykge1xuICAgICAgdGhpcy5ydW5RdWV1ZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBTdWJzY3JpcHRpb24gPSBjbGFzcyB7XG4gIHJlbGF5O1xuICBpZDtcbiAgY2xvc2VkID0gZmFsc2U7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGZpbHRlcnM7XG4gIGFscmVhZHlIYXZlRXZlbnQ7XG4gIHJlY2VpdmVkRXZlbnQ7XG4gIG9uZXZlbnQ7XG4gIG9uZW9zZTtcbiAgb25jbG9zZTtcbiAgZW9zZVRpbWVvdXQ7XG4gIGVvc2VUaW1lb3V0SGFuZGxlO1xuICBjb25zdHJ1Y3RvcihyZWxheSwgaWQsIGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmFscmVhZHlIYXZlRXZlbnQgPSBwYXJhbXMuYWxyZWFkeUhhdmVFdmVudDtcbiAgICB0aGlzLnJlY2VpdmVkRXZlbnQgPSBwYXJhbXMucmVjZWl2ZWRFdmVudDtcbiAgICB0aGlzLmVvc2VUaW1lb3V0ID0gcGFyYW1zLmVvc2VUaW1lb3V0IHx8IHJlbGF5LmJhc2VFb3NlVGltZW91dDtcbiAgICB0aGlzLm9uZW9zZSA9IHBhcmFtcy5vbmVvc2U7XG4gICAgdGhpcy5vbmNsb3NlID0gcGFyYW1zLm9uY2xvc2U7XG4gICAgdGhpcy5vbmV2ZW50ID0gcGFyYW1zLm9uZXZlbnQgfHwgKChldmVudCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgb25ldmVudCgpIGNhbGxiYWNrIG5vdCBkZWZpbmVkIGZvciBzdWJzY3JpcHRpb24gJyR7dGhpcy5pZH0nIGluIHJlbGF5ICR7dGhpcy5yZWxheS51cmx9LiBldmVudCByZWNlaXZlZDpgLFxuICAgICAgICBldmVudFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBmaXJlKCkge1xuICAgIHRoaXMucmVsYXkuc2VuZCgnW1wiUkVRXCIsXCInICsgdGhpcy5pZCArICdcIiwnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5maWx0ZXJzKS5zdWJzdHJpbmcoMSkpO1xuICAgIHRoaXMuZW9zZVRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KHRoaXMucmVjZWl2ZWRFb3NlLmJpbmQodGhpcyksIHRoaXMuZW9zZVRpbWVvdXQpO1xuICB9XG4gIHJlY2VpdmVkRW9zZSgpIHtcbiAgICBpZiAodGhpcy5lb3NlZClcbiAgICAgIHJldHVybjtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dEhhbmRsZSk7XG4gICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgdGhpcy5vbmVvc2U/LigpO1xuICB9XG4gIGNsb3NlKHJlYXNvbiA9IFwiY2xvc2VkIGJ5IGNhbGxlclwiKSB7XG4gICAgaWYgKCF0aGlzLmNsb3NlZCAmJiB0aGlzLnJlbGF5LmNvbm5lY3RlZCkge1xuICAgICAgdGhpcy5yZWxheS5zZW5kKCdbXCJDTE9TRVwiLCcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmlkKSArIFwiXVwiKTtcbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5yZWxheS5vcGVuU3Vicy5kZWxldGUodGhpcy5pZCk7XG4gICAgdGhpcy5vbmNsb3NlPy4ocmVhc29uKTtcbiAgfVxufTtcblxuLy8gcmVsYXkudHNcbnZhciBfV2ViU29ja2V0O1xudHJ5IHtcbiAgX1dlYlNvY2tldCA9IFdlYlNvY2tldDtcbn0gY2F0Y2gge1xufVxudmFyIFJlbGF5ID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFJlbGF5IHtcbiAgY29uc3RydWN0b3IodXJsKSB7XG4gICAgc3VwZXIodXJsLCB7IHZlcmlmeUV2ZW50LCB3ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbjogX1dlYlNvY2tldCB9KTtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY29ubmVjdCh1cmwpIHtcbiAgICBjb25zdCByZWxheSA9IG5ldyBSZWxheSh1cmwpO1xuICAgIGF3YWl0IHJlbGF5LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbn07XG5cbi8vIGFic3RyYWN0LXBvb2wudHNcbnZhciBBYnN0cmFjdFNpbXBsZVBvb2wgPSBjbGFzcyB7XG4gIHJlbGF5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHNlZW5PbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHRyYWNrUmVsYXlzID0gZmFsc2U7XG4gIHZlcmlmeUV2ZW50O1xuICB0cnVzdGVkUmVsYXlVUkxzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgX1dlYlNvY2tldDtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMudmVyaWZ5RXZlbnQgPSBvcHRzLnZlcmlmeUV2ZW50O1xuICAgIHRoaXMuX1dlYlNvY2tldCA9IG9wdHMud2Vic29ja2V0SW1wbGVtZW50YXRpb247XG4gIH1cbiAgYXN5bmMgZW5zdXJlUmVsYXkodXJsLCBwYXJhbXMpIHtcbiAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICBsZXQgcmVsYXkgPSB0aGlzLnJlbGF5cy5nZXQodXJsKTtcbiAgICBpZiAoIXJlbGF5KSB7XG4gICAgICByZWxheSA9IG5ldyBBYnN0cmFjdFJlbGF5KHVybCwge1xuICAgICAgICB2ZXJpZnlFdmVudDogdGhpcy50cnVzdGVkUmVsYXlVUkxzLmhhcyh1cmwpID8gYWx3YXlzVHJ1ZSA6IHRoaXMudmVyaWZ5RXZlbnQsXG4gICAgICAgIHdlYnNvY2tldEltcGxlbWVudGF0aW9uOiB0aGlzLl9XZWJTb2NrZXRcbiAgICAgIH0pO1xuICAgICAgaWYgKHBhcmFtcz8uY29ubmVjdGlvblRpbWVvdXQpXG4gICAgICAgIHJlbGF5LmNvbm5lY3Rpb25UaW1lb3V0ID0gcGFyYW1zLmNvbm5lY3Rpb25UaW1lb3V0O1xuICAgICAgdGhpcy5yZWxheXMuc2V0KHVybCwgcmVsYXkpO1xuICAgIH1cbiAgICBhd2FpdCByZWxheS5jb25uZWN0KCk7XG4gICAgcmV0dXJuIHJlbGF5O1xuICB9XG4gIGNsb3NlKHJlbGF5cykge1xuICAgIHJlbGF5cy5tYXAobm9ybWFsaXplVVJMKS5mb3JFYWNoKCh1cmwpID0+IHtcbiAgICAgIHRoaXMucmVsYXlzLmdldCh1cmwpPy5jbG9zZSgpO1xuICAgIH0pO1xuICB9XG4gIHN1YnNjcmliZU1hbnkocmVsYXlzLCBmaWx0ZXJzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpYmVNYW55TWFwKE9iamVjdC5mcm9tRW50cmllcyhyZWxheXMubWFwKCh1cmwpID0+IFt1cmwsIGZpbHRlcnNdKSksIHBhcmFtcyk7XG4gIH1cbiAgc3Vic2NyaWJlTWFueU1hcChyZXF1ZXN0cywgcGFyYW1zKSB7XG4gICAgaWYgKHRoaXMudHJhY2tSZWxheXMpIHtcbiAgICAgIHBhcmFtcy5yZWNlaXZlZEV2ZW50ID0gKHJlbGF5LCBpZCkgPT4ge1xuICAgICAgICBsZXQgc2V0ID0gdGhpcy5zZWVuT24uZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgICBzZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgIHRoaXMuc2Vlbk9uLnNldChpZCwgc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBzZXQuYWRkKHJlbGF5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IF9rbm93bklkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3Qgc3VicyA9IFtdO1xuICAgIGNvbnN0IHJlbGF5c0xlbmd0aCA9IE9iamVjdC5rZXlzKHJlcXVlc3RzKS5sZW5ndGg7XG4gICAgY29uc3QgZW9zZXNSZWNlaXZlZCA9IFtdO1xuICAgIGxldCBoYW5kbGVFb3NlID0gKGkyKSA9PiB7XG4gICAgICBlb3Nlc1JlY2VpdmVkW2kyXSA9IHRydWU7XG4gICAgICBpZiAoZW9zZXNSZWNlaXZlZC5maWx0ZXIoKGEpID0+IGEpLmxlbmd0aCA9PT0gcmVsYXlzTGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5vbmVvc2U/LigpO1xuICAgICAgICBoYW5kbGVFb3NlID0gKCkgPT4ge1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2xvc2VzUmVjZWl2ZWQgPSBbXTtcbiAgICBsZXQgaGFuZGxlQ2xvc2UgPSAoaTIsIHJlYXNvbikgPT4ge1xuICAgICAgaGFuZGxlRW9zZShpMik7XG4gICAgICBjbG9zZXNSZWNlaXZlZFtpMl0gPSByZWFzb247XG4gICAgICBpZiAoY2xvc2VzUmVjZWl2ZWQuZmlsdGVyKChhKSA9PiBhKS5sZW5ndGggPT09IHJlbGF5c0xlbmd0aCkge1xuICAgICAgICBwYXJhbXMub25jbG9zZT8uKGNsb3Nlc1JlY2VpdmVkKTtcbiAgICAgICAgaGFuZGxlQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBsb2NhbEFscmVhZHlIYXZlRXZlbnRIYW5kbGVyID0gKGlkKSA9PiB7XG4gICAgICBpZiAocGFyYW1zLmFscmVhZHlIYXZlRXZlbnQ/LihpZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBoYXZlID0gX2tub3duSWRzLmhhcyhpZCk7XG4gICAgICBfa25vd25JZHMuYWRkKGlkKTtcbiAgICAgIHJldHVybiBoYXZlO1xuICAgIH07XG4gICAgY29uc3QgYWxsT3BlbmVkID0gUHJvbWlzZS5hbGwoXG4gICAgICBPYmplY3QuZW50cmllcyhyZXF1ZXN0cykubWFwKGFzeW5jIChyZXEsIGkyLCBhcnIpID0+IHtcbiAgICAgICAgaWYgKGFyci5pbmRleE9mKHJlcSkgIT09IGkyKSB7XG4gICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIFwiZHVwbGljYXRlIHVybFwiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFt1cmwsIGZpbHRlcnNdID0gcmVxO1xuICAgICAgICB1cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICAgICAgbGV0IHJlbGF5O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlbGF5ID0gYXdhaXQgdGhpcy5lbnN1cmVSZWxheSh1cmwsIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25UaW1lb3V0OiBwYXJhbXMubWF4V2FpdCA/IE1hdGgubWF4KHBhcmFtcy5tYXhXYWl0ICogMC44LCBwYXJhbXMubWF4V2FpdCAtIDFlMykgOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaGFuZGxlQ2xvc2UoaTIsIGVycj8ubWVzc2FnZSB8fCBTdHJpbmcoZXJyKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdWJzY3JpcHRpb24gPSByZWxheS5zdWJzY3JpYmUoZmlsdGVycywge1xuICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICBvbmVvc2U6ICgpID0+IGhhbmRsZUVvc2UoaTIpLFxuICAgICAgICAgIG9uY2xvc2U6IChyZWFzb24pID0+IGhhbmRsZUNsb3NlKGkyLCByZWFzb24pLFxuICAgICAgICAgIGFscmVhZHlIYXZlRXZlbnQ6IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIsXG4gICAgICAgICAgZW9zZVRpbWVvdXQ6IHBhcmFtcy5tYXhXYWl0XG4gICAgICAgIH0pO1xuICAgICAgICBzdWJzLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgY2xvc2UoKSB7XG4gICAgICAgIGF3YWl0IGFsbE9wZW5lZDtcbiAgICAgICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgICAgICBzdWIuY2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBzdWJzY3JpYmVNYW55RW9zZShyZWxheXMsIGZpbHRlcnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHN1YmNsb3NlciA9IHRoaXMuc3Vic2NyaWJlTWFueShyZWxheXMsIGZpbHRlcnMsIHtcbiAgICAgIC4uLnBhcmFtcyxcbiAgICAgIG9uZW9zZSgpIHtcbiAgICAgICAgc3ViY2xvc2VyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN1YmNsb3NlcjtcbiAgfVxuICBhc3luYyBxdWVyeVN5bmMocmVsYXlzLCBmaWx0ZXIsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3QgZXZlbnRzID0gW107XG4gICAgICB0aGlzLnN1YnNjcmliZU1hbnlFb3NlKHJlbGF5cywgW2ZpbHRlcl0sIHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBvbmV2ZW50KGV2ZW50KSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBvbmNsb3NlKF8pIHtcbiAgICAgICAgICByZXNvbHZlKGV2ZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIGdldChyZWxheXMsIGZpbHRlciwgcGFyYW1zKSB7XG4gICAgZmlsdGVyLmxpbWl0ID0gMTtcbiAgICBjb25zdCBldmVudHMgPSBhd2FpdCB0aGlzLnF1ZXJ5U3luYyhyZWxheXMsIGZpbHRlciwgcGFyYW1zKTtcbiAgICBldmVudHMuc29ydCgoYSwgYikgPT4gYi5jcmVhdGVkX2F0IC0gYS5jcmVhdGVkX2F0KTtcbiAgICByZXR1cm4gZXZlbnRzWzBdIHx8IG51bGw7XG4gIH1cbiAgcHVibGlzaChyZWxheXMsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJlbGF5cy5tYXAobm9ybWFsaXplVVJMKS5tYXAoYXN5bmMgKHVybCwgaTIsIGFycikgPT4ge1xuICAgICAgaWYgKGFyci5pbmRleE9mKHVybCkgIT09IGkyKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcImR1cGxpY2F0ZSB1cmxcIik7XG4gICAgICB9XG4gICAgICBsZXQgciA9IGF3YWl0IHRoaXMuZW5zdXJlUmVsYXkodXJsKTtcbiAgICAgIHJldHVybiByLnB1Ymxpc2goZXZlbnQpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBwb29sLnRzXG52YXIgX1dlYlNvY2tldDI7XG50cnkge1xuICBfV2ViU29ja2V0MiA9IFdlYlNvY2tldDtcbn0gY2F0Y2gge1xufVxudmFyIFNpbXBsZVBvb2wgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0U2ltcGxlUG9vbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgdmVyaWZ5RXZlbnQsIHdlYnNvY2tldEltcGxlbWVudGF0aW9uOiBfV2ViU29ja2V0MiB9KTtcbiAgfVxufTtcblxuLy8gbmlwMTkudHNcbnZhciBuaXAxOV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxOV9leHBvcnRzLCB7XG4gIEJFQ0gzMl9SRUdFWDogKCkgPT4gQkVDSDMyX1JFR0VYLFxuICBCZWNoMzJNYXhTaXplOiAoKSA9PiBCZWNoMzJNYXhTaXplLFxuICBkZWNvZGU6ICgpID0+IGRlY29kZSxcbiAgZW5jb2RlQnl0ZXM6ICgpID0+IGVuY29kZUJ5dGVzLFxuICBuYWRkckVuY29kZTogKCkgPT4gbmFkZHJFbmNvZGUsXG4gIG5ldmVudEVuY29kZTogKCkgPT4gbmV2ZW50RW5jb2RlLFxuICBub3RlRW5jb2RlOiAoKSA9PiBub3RlRW5jb2RlLFxuICBucHJvZmlsZUVuY29kZTogKCkgPT4gbnByb2ZpbGVFbmNvZGUsXG4gIG5wdWJFbmNvZGU6ICgpID0+IG5wdWJFbmNvZGUsXG4gIG5yZWxheUVuY29kZTogKCkgPT4gbnJlbGF5RW5jb2RlLFxuICBuc2VjRW5jb2RlOiAoKSA9PiBuc2VjRW5jb2RlXG59KTtcbmltcG9ydCB7IGJ5dGVzVG9IZXggYXMgYnl0ZXNUb0hleDIsIGNvbmNhdEJ5dGVzLCBoZXhUb0J5dGVzIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvdXRpbHNcIjtcbmltcG9ydCB7IGJlY2gzMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIEJlY2gzMk1heFNpemUgPSA1ZTM7XG52YXIgQkVDSDMyX1JFR0VYID0gL1tcXHgyMS1cXHg3RV17MSw4M30xWzAyMzQ1Njc4OWFjZGVmZ2hqa2xtbnBxcnN0dXZ3eHl6XXs2LH0vO1xuZnVuY3Rpb24gaW50ZWdlclRvVWludDhBcnJheShudW1iZXIpIHtcbiAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KDQpO1xuICB1aW50OEFycmF5WzBdID0gbnVtYmVyID4+IDI0ICYgMjU1O1xuICB1aW50OEFycmF5WzFdID0gbnVtYmVyID4+IDE2ICYgMjU1O1xuICB1aW50OEFycmF5WzJdID0gbnVtYmVyID4+IDggJiAyNTU7XG4gIHVpbnQ4QXJyYXlbM10gPSBudW1iZXIgJiAyNTU7XG4gIHJldHVybiB1aW50OEFycmF5O1xufVxuZnVuY3Rpb24gZGVjb2RlKG5pcDE5KSB7XG4gIGxldCB7IHByZWZpeCwgd29yZHMgfSA9IGJlY2gzMi5kZWNvZGUobmlwMTksIEJlY2gzMk1heFNpemUpO1xuICBsZXQgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJlY2gzMi5mcm9tV29yZHMod29yZHMpKTtcbiAgc3dpdGNoIChwcmVmaXgpIHtcbiAgICBjYXNlIFwibnByb2ZpbGVcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbnByb2ZpbGVcIik7XG4gICAgICBpZiAodGx2WzBdWzBdLmxlbmd0aCAhPT0gMzIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRMViAwIHNob3VsZCBiZSAzMiBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibnByb2ZpbGVcIixcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHB1YmtleTogYnl0ZXNUb0hleDIodGx2WzBdWzBdKSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibmV2ZW50XCI6IHtcbiAgICAgIGxldCB0bHYgPSBwYXJzZVRMVihkYXRhKTtcbiAgICAgIGlmICghdGx2WzBdPy5bMF0pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgVExWIDAgZm9yIG5ldmVudFwiKTtcbiAgICAgIGlmICh0bHZbMF1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDAgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKHRsdlsyXSAmJiB0bHZbMl1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDIgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKHRsdlszXSAmJiB0bHZbM11bMF0ubGVuZ3RoICE9PSA0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUTFYgMyBzaG91bGQgYmUgNCBieXRlc1wiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibmV2ZW50XCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZDogYnl0ZXNUb0hleDIodGx2WzBdWzBdKSxcbiAgICAgICAgICByZWxheXM6IHRsdlsxXSA/IHRsdlsxXS5tYXAoKGQpID0+IHV0ZjhEZWNvZGVyLmRlY29kZShkKSkgOiBbXSxcbiAgICAgICAgICBhdXRob3I6IHRsdlsyXT8uWzBdID8gYnl0ZXNUb0hleDIodGx2WzJdWzBdKSA6IHZvaWQgMCxcbiAgICAgICAgICBraW5kOiB0bHZbM10/LlswXSA/IHBhcnNlSW50KGJ5dGVzVG9IZXgyKHRsdlszXVswXSksIDE2KSA6IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwibmFkZHJcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAoIXRsdlsyXT8uWzBdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFRMViAyIGZvciBuYWRkclwiKTtcbiAgICAgIGlmICh0bHZbMl1bMF0ubGVuZ3RoICE9PSAzMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDIgc2hvdWxkIGJlIDMyIGJ5dGVzXCIpO1xuICAgICAgaWYgKCF0bHZbM10/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMyBmb3IgbmFkZHJcIik7XG4gICAgICBpZiAodGx2WzNdWzBdLmxlbmd0aCAhPT0gNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVExWIDMgc2hvdWxkIGJlIDQgYnl0ZXNcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5hZGRyXCIsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBpZGVudGlmaWVyOiB1dGY4RGVjb2Rlci5kZWNvZGUodGx2WzBdWzBdKSxcbiAgICAgICAgICBwdWJrZXk6IGJ5dGVzVG9IZXgyKHRsdlsyXVswXSksXG4gICAgICAgICAga2luZDogcGFyc2VJbnQoYnl0ZXNUb0hleDIodGx2WzNdWzBdKSwgMTYpLFxuICAgICAgICAgIHJlbGF5czogdGx2WzFdID8gdGx2WzFdLm1hcCgoZCkgPT4gdXRmOERlY29kZXIuZGVjb2RlKGQpKSA6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJucmVsYXlcIjoge1xuICAgICAgbGV0IHRsdiA9IHBhcnNlVExWKGRhdGEpO1xuICAgICAgaWYgKCF0bHZbMF0/LlswXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBUTFYgMCBmb3IgbnJlbGF5XCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJucmVsYXlcIixcbiAgICAgICAgZGF0YTogdXRmOERlY29kZXIuZGVjb2RlKHRsdlswXVswXSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJuc2VjXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBwcmVmaXgsIGRhdGEgfTtcbiAgICBjYXNlIFwibnB1YlwiOlxuICAgIGNhc2UgXCJub3RlXCI6XG4gICAgICByZXR1cm4geyB0eXBlOiBwcmVmaXgsIGRhdGE6IGJ5dGVzVG9IZXgyKGRhdGEpIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBwcmVmaXggJHtwcmVmaXh9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVExWKGRhdGEpIHtcbiAgbGV0IHJlc3VsdCA9IHt9O1xuICBsZXQgcmVzdCA9IGRhdGE7XG4gIHdoaWxlIChyZXN0Lmxlbmd0aCA+IDApIHtcbiAgICBsZXQgdCA9IHJlc3RbMF07XG4gICAgbGV0IGwgPSByZXN0WzFdO1xuICAgIGxldCB2ID0gcmVzdC5zbGljZSgyLCAyICsgbCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMiArIGwpO1xuICAgIGlmICh2Lmxlbmd0aCA8IGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vdCBlbm91Z2ggZGF0YSB0byByZWFkIG9uIFRMViAke3R9YCk7XG4gICAgcmVzdWx0W3RdID0gcmVzdWx0W3RdIHx8IFtdO1xuICAgIHJlc3VsdFt0XS5wdXNoKHYpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBuc2VjRW5jb2RlKGtleSkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJuc2VjXCIsIGtleSk7XG59XG5mdW5jdGlvbiBucHViRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJucHViXCIsIGhleFRvQnl0ZXMoaGV4KSk7XG59XG5mdW5jdGlvbiBub3RlRW5jb2RlKGhleCkge1xuICByZXR1cm4gZW5jb2RlQnl0ZXMoXCJub3RlXCIsIGhleFRvQnl0ZXMoaGV4KSk7XG59XG5mdW5jdGlvbiBlbmNvZGVCZWNoMzIocHJlZml4LCBkYXRhKSB7XG4gIGxldCB3b3JkcyA9IGJlY2gzMi50b1dvcmRzKGRhdGEpO1xuICByZXR1cm4gYmVjaDMyLmVuY29kZShwcmVmaXgsIHdvcmRzLCBCZWNoMzJNYXhTaXplKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKHByZWZpeCwgYnl0ZXMpIHtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihwcmVmaXgsIGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIG5wcm9maWxlRW5jb2RlKHByb2ZpbGUpIHtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFtoZXhUb0J5dGVzKHByb2ZpbGUucHVia2V5KV0sXG4gICAgMTogKHByb2ZpbGUucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKFwibnByb2ZpbGVcIiwgZGF0YSk7XG59XG5mdW5jdGlvbiBuZXZlbnRFbmNvZGUoZXZlbnQpIHtcbiAgbGV0IGtpbmRBcnJheTtcbiAgaWYgKGV2ZW50LmtpbmQgIT09IHZvaWQgMCkge1xuICAgIGtpbmRBcnJheSA9IGludGVnZXJUb1VpbnQ4QXJyYXkoZXZlbnQua2luZCk7XG4gIH1cbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFtoZXhUb0J5dGVzKGV2ZW50LmlkKV0sXG4gICAgMTogKGV2ZW50LnJlbGF5cyB8fCBbXSkubWFwKCh1cmwpID0+IHV0ZjhFbmNvZGVyLmVuY29kZSh1cmwpKSxcbiAgICAyOiBldmVudC5hdXRob3IgPyBbaGV4VG9CeXRlcyhldmVudC5hdXRob3IpXSA6IFtdLFxuICAgIDM6IGtpbmRBcnJheSA/IFtuZXcgVWludDhBcnJheShraW5kQXJyYXkpXSA6IFtdXG4gIH0pO1xuICByZXR1cm4gZW5jb2RlQmVjaDMyKFwibmV2ZW50XCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gbmFkZHJFbmNvZGUoYWRkcikge1xuICBsZXQga2luZCA9IG5ldyBBcnJheUJ1ZmZlcig0KTtcbiAgbmV3IERhdGFWaWV3KGtpbmQpLnNldFVpbnQzMigwLCBhZGRyLmtpbmQsIGZhbHNlKTtcbiAgbGV0IGRhdGEgPSBlbmNvZGVUTFYoe1xuICAgIDA6IFt1dGY4RW5jb2Rlci5lbmNvZGUoYWRkci5pZGVudGlmaWVyKV0sXG4gICAgMTogKGFkZHIucmVsYXlzIHx8IFtdKS5tYXAoKHVybCkgPT4gdXRmOEVuY29kZXIuZW5jb2RlKHVybCkpLFxuICAgIDI6IFtoZXhUb0J5dGVzKGFkZHIucHVia2V5KV0sXG4gICAgMzogW25ldyBVaW50OEFycmF5KGtpbmQpXVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5hZGRyXCIsIGRhdGEpO1xufVxuZnVuY3Rpb24gbnJlbGF5RW5jb2RlKHVybCkge1xuICBsZXQgZGF0YSA9IGVuY29kZVRMVih7XG4gICAgMDogW3V0ZjhFbmNvZGVyLmVuY29kZSh1cmwpXVxuICB9KTtcbiAgcmV0dXJuIGVuY29kZUJlY2gzMihcIm5yZWxheVwiLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGVuY29kZVRMVih0bHYpIHtcbiAgbGV0IGVudHJpZXMgPSBbXTtcbiAgT2JqZWN0LmVudHJpZXModGx2KS5yZXZlcnNlKCkuZm9yRWFjaCgoW3QsIHZzXSkgPT4ge1xuICAgIHZzLmZvckVhY2goKHYpID0+IHtcbiAgICAgIGxldCBlbnRyeSA9IG5ldyBVaW50OEFycmF5KHYubGVuZ3RoICsgMik7XG4gICAgICBlbnRyeS5zZXQoW3BhcnNlSW50KHQpXSwgMCk7XG4gICAgICBlbnRyeS5zZXQoW3YubGVuZ3RoXSwgMSk7XG4gICAgICBlbnRyeS5zZXQodiwgMik7XG4gICAgICBlbnRyaWVzLnB1c2goZW50cnkpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLmVudHJpZXMpO1xufVxuXG4vLyByZWZlcmVuY2VzLnRzXG52YXIgbWVudGlvblJlZ2V4ID0gL1xcYm5vc3RyOigobm90ZXxucHVifG5hZGRyfG5ldmVudHxucHJvZmlsZSkxXFx3KylcXGJ8I1xcWyhcXGQrKVxcXS9nO1xuZnVuY3Rpb24gcGFyc2VSZWZlcmVuY2VzKGV2dCkge1xuICBsZXQgcmVmZXJlbmNlcyA9IFtdO1xuICBmb3IgKGxldCByZWYgb2YgZXZ0LmNvbnRlbnQubWF0Y2hBbGwobWVudGlvblJlZ2V4KSkge1xuICAgIGlmIChyZWZbMl0pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCB7IHR5cGUsIGRhdGEgfSA9IGRlY29kZShyZWZbMV0pO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwibnB1YlwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIHByb2ZpbGU6IHsgcHVia2V5OiBkYXRhLCByZWxheXM6IFtdIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJucHJvZmlsZVwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIHByb2ZpbGU6IGRhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJub3RlXCI6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHJlZlswXSxcbiAgICAgICAgICAgICAgZXZlbnQ6IHsgaWQ6IGRhdGEsIHJlbGF5czogW10gfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm5ldmVudFwiOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGV2ZW50OiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwibmFkZHJcIjoge1xuICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgICBhZGRyZXNzOiBkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWZbM10pIHtcbiAgICAgIGxldCBpZHggPSBwYXJzZUludChyZWZbM10sIDEwKTtcbiAgICAgIGxldCB0YWcgPSBldnQudGFnc1tpZHhdO1xuICAgICAgaWYgKCF0YWcpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgc3dpdGNoICh0YWdbMF0pIHtcbiAgICAgICAgY2FzZSBcInBcIjoge1xuICAgICAgICAgIHJlZmVyZW5jZXMucHVzaCh7XG4gICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICBwcm9maWxlOiB7IHB1YmtleTogdGFnWzFdLCByZWxheXM6IHRhZ1syXSA/IFt0YWdbMl1dIDogW10gfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJlXCI6IHtcbiAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgdGV4dDogcmVmWzBdLFxuICAgICAgICAgICAgZXZlbnQ6IHsgaWQ6IHRhZ1sxXSwgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYVwiOiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBba2luZCwgcHVia2V5LCBpZGVudGlmaWVyXSA9IHRhZ1sxXS5zcGxpdChcIjpcIik7XG4gICAgICAgICAgICByZWZlcmVuY2VzLnB1c2goe1xuICAgICAgICAgICAgICB0ZXh0OiByZWZbMF0sXG4gICAgICAgICAgICAgIGFkZHJlc3M6IHtcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICAgICAgICBraW5kOiBwYXJzZUludChraW5kLCAxMCksXG4gICAgICAgICAgICAgICAgcmVsYXlzOiB0YWdbMl0gPyBbdGFnWzJdXSA6IFtdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVmZXJlbmNlcztcbn1cblxuLy8gbmlwMDQudHNcbnZhciBuaXAwNF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAwNF9leHBvcnRzLCB7XG4gIGRlY3J5cHQ6ICgpID0+IGRlY3J5cHQsXG4gIGVuY3J5cHQ6ICgpID0+IGVuY3J5cHRcbn0pO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4MywgcmFuZG9tQnl0ZXMgfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBjYmMgfSBmcm9tIFwiQG5vYmxlL2NpcGhlcnMvYWVzXCI7XG5pbXBvcnQgeyBiYXNlNjQgfSBmcm9tIFwiQHNjdXJlL2Jhc2VcIjtcbmFzeW5jIGZ1bmN0aW9uIGVuY3J5cHQoc2VjcmV0S2V5LCBwdWJrZXksIHRleHQpIHtcbiAgY29uc3QgcHJpdmtleSA9IHNlY3JldEtleSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBieXRlc1RvSGV4MyhzZWNyZXRLZXkpIDogc2VjcmV0S2V5O1xuICBjb25zdCBrZXkgPSBzZWNwMjU2azEuZ2V0U2hhcmVkU2VjcmV0KHByaXZrZXksIFwiMDJcIiArIHB1YmtleSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRLZXkgPSBnZXROb3JtYWxpemVkWChrZXkpO1xuICBsZXQgaXYgPSBVaW50OEFycmF5LmZyb20ocmFuZG9tQnl0ZXMoMTYpKTtcbiAgbGV0IHBsYWludGV4dCA9IHV0ZjhFbmNvZGVyLmVuY29kZSh0ZXh0KTtcbiAgbGV0IGNpcGhlcnRleHQgPSBjYmMobm9ybWFsaXplZEtleSwgaXYpLmVuY3J5cHQocGxhaW50ZXh0KTtcbiAgbGV0IGN0YjY0ID0gYmFzZTY0LmVuY29kZShuZXcgVWludDhBcnJheShjaXBoZXJ0ZXh0KSk7XG4gIGxldCBpdmI2NCA9IGJhc2U2NC5lbmNvZGUobmV3IFVpbnQ4QXJyYXkoaXYuYnVmZmVyKSk7XG4gIHJldHVybiBgJHtjdGI2NH0/aXY9JHtpdmI2NH1gO1xufVxuYXN5bmMgZnVuY3Rpb24gZGVjcnlwdChzZWNyZXRLZXksIHB1YmtleSwgZGF0YSkge1xuICBjb25zdCBwcml2a2V5ID0gc2VjcmV0S2V5IGluc3RhbmNlb2YgVWludDhBcnJheSA/IGJ5dGVzVG9IZXgzKHNlY3JldEtleSkgOiBzZWNyZXRLZXk7XG4gIGxldCBbY3RiNjQsIGl2YjY0XSA9IGRhdGEuc3BsaXQoXCI/aXY9XCIpO1xuICBsZXQga2V5ID0gc2VjcDI1NmsxLmdldFNoYXJlZFNlY3JldChwcml2a2V5LCBcIjAyXCIgKyBwdWJrZXkpO1xuICBsZXQgbm9ybWFsaXplZEtleSA9IGdldE5vcm1hbGl6ZWRYKGtleSk7XG4gIGxldCBpdiA9IGJhc2U2NC5kZWNvZGUoaXZiNjQpO1xuICBsZXQgY2lwaGVydGV4dCA9IGJhc2U2NC5kZWNvZGUoY3RiNjQpO1xuICBsZXQgcGxhaW50ZXh0ID0gY2JjKG5vcm1hbGl6ZWRLZXksIGl2KS5kZWNyeXB0KGNpcGhlcnRleHQpO1xuICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKHBsYWludGV4dCk7XG59XG5mdW5jdGlvbiBnZXROb3JtYWxpemVkWChrZXkpIHtcbiAgcmV0dXJuIGtleS5zbGljZSgxLCAzMyk7XG59XG5cbi8vIG5pcDA1LnRzXG52YXIgbmlwMDVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMDVfZXhwb3J0cywge1xuICBOSVAwNV9SRUdFWDogKCkgPT4gTklQMDVfUkVHRVgsXG4gIGlzVmFsaWQ6ICgpID0+IGlzVmFsaWQsXG4gIHF1ZXJ5UHJvZmlsZTogKCkgPT4gcXVlcnlQcm9maWxlLFxuICBzZWFyY2hEb21haW46ICgpID0+IHNlYXJjaERvbWFpbixcbiAgdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjogKCkgPT4gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvblxufSk7XG52YXIgTklQMDVfUkVHRVggPSAvXig/OihbXFx3ListXSspQCk/KFtcXHdfLV0rKFxcLltcXHdfLV0rKSspJC87XG52YXIgX2ZldGNoO1xudHJ5IHtcbiAgX2ZldGNoID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb24oZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2ggPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gc2VhcmNoRG9tYWluKGRvbWFpbiwgcXVlcnkgPSBcIlwiKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYGh0dHBzOi8vJHtkb21haW59Ly53ZWxsLWtub3duL25vc3RyLmpzb24/bmFtZT0ke3F1ZXJ5fWA7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgX2ZldGNoKHVybCwgeyByZWRpcmVjdDogXCJlcnJvclwiIH0pO1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIHJldHVybiBqc29uLm5hbWVzO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBxdWVyeVByb2ZpbGUoZnVsbG5hbWUpIHtcbiAgY29uc3QgbWF0Y2ggPSBmdWxsbmFtZS5tYXRjaChOSVAwNV9SRUdFWCk7XG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IFtfLCBuYW1lID0gXCJfXCIsIGRvbWFpbl0gPSBtYXRjaDtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBgaHR0cHM6Ly8ke2RvbWFpbn0vLndlbGwta25vd24vbm9zdHIuanNvbj9uYW1lPSR7bmFtZX1gO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IChhd2FpdCBfZmV0Y2godXJsLCB7IHJlZGlyZWN0OiBcImVycm9yXCIgfSkpLmpzb24oKTtcbiAgICBsZXQgcHVia2V5ID0gcmVzLm5hbWVzW25hbWVdO1xuICAgIHJldHVybiBwdWJrZXkgPyB7IHB1YmtleSwgcmVsYXlzOiByZXMucmVsYXlzPy5bcHVia2V5XSB9IDogbnVsbDtcbiAgfSBjYXRjaCAoX2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gaXNWYWxpZChwdWJrZXksIG5pcDA1KSB7XG4gIGxldCByZXMgPSBhd2FpdCBxdWVyeVByb2ZpbGUobmlwMDUpO1xuICByZXR1cm4gcmVzID8gcmVzLnB1YmtleSA9PT0gcHVia2V5IDogZmFsc2U7XG59XG5cbi8vIG5pcDEwLnRzXG52YXIgbmlwMTBfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMTBfZXhwb3J0cywge1xuICBwYXJzZTogKCkgPT4gcGFyc2Vcbn0pO1xuZnVuY3Rpb24gcGFyc2UoZXZlbnQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHJlcGx5OiB2b2lkIDAsXG4gICAgcm9vdDogdm9pZCAwLFxuICAgIG1lbnRpb25zOiBbXSxcbiAgICBwcm9maWxlczogW11cbiAgfTtcbiAgY29uc3QgZVRhZ3MgPSBbXTtcbiAgZm9yIChjb25zdCB0YWcgb2YgZXZlbnQudGFncykge1xuICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIHRhZ1sxXSkge1xuICAgICAgZVRhZ3MucHVzaCh0YWcpO1xuICAgIH1cbiAgICBpZiAodGFnWzBdID09PSBcInBcIiAmJiB0YWdbMV0pIHtcbiAgICAgIHJlc3VsdC5wcm9maWxlcy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiB0YWdbMV0sXG4gICAgICAgIHJlbGF5czogdGFnWzJdID8gW3RhZ1syXV0gOiBbXVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGVUYWdJbmRleCA9IDA7IGVUYWdJbmRleCA8IGVUYWdzLmxlbmd0aDsgZVRhZ0luZGV4KyspIHtcbiAgICBjb25zdCBlVGFnID0gZVRhZ3NbZVRhZ0luZGV4XTtcbiAgICBjb25zdCBbXywgZVRhZ0V2ZW50SWQsIGVUYWdSZWxheVVybCwgZVRhZ01hcmtlcl0gPSBlVGFnO1xuICAgIGNvbnN0IGV2ZW50UG9pbnRlciA9IHtcbiAgICAgIGlkOiBlVGFnRXZlbnRJZCxcbiAgICAgIHJlbGF5czogZVRhZ1JlbGF5VXJsID8gW2VUYWdSZWxheVVybF0gOiBbXVxuICAgIH07XG4gICAgY29uc3QgaXNGaXJzdEVUYWcgPSBlVGFnSW5kZXggPT09IDA7XG4gICAgY29uc3QgaXNMYXN0RVRhZyA9IGVUYWdJbmRleCA9PT0gZVRhZ3MubGVuZ3RoIC0gMTtcbiAgICBpZiAoZVRhZ01hcmtlciA9PT0gXCJyb290XCIpIHtcbiAgICAgIHJlc3VsdC5yb290ID0gZXZlbnRQb2ludGVyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChlVGFnTWFya2VyID09PSBcInJlcGx5XCIpIHtcbiAgICAgIHJlc3VsdC5yZXBseSA9IGV2ZW50UG9pbnRlcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZVRhZ01hcmtlciA9PT0gXCJtZW50aW9uXCIpIHtcbiAgICAgIHJlc3VsdC5tZW50aW9ucy5wdXNoKGV2ZW50UG9pbnRlcik7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGlzRmlyc3RFVGFnKSB7XG4gICAgICByZXN1bHQucm9vdCA9IGV2ZW50UG9pbnRlcjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaXNMYXN0RVRhZykge1xuICAgICAgcmVzdWx0LnJlcGx5ID0gZXZlbnRQb2ludGVyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdC5tZW50aW9ucy5wdXNoKGV2ZW50UG9pbnRlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gbmlwMTEudHNcbnZhciBuaXAxMV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAxMV9leHBvcnRzLCB7XG4gIGZldGNoUmVsYXlJbmZvcm1hdGlvbjogKCkgPT4gZmV0Y2hSZWxheUluZm9ybWF0aW9uLFxuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMlxufSk7XG52YXIgX2ZldGNoMjtcbnRyeSB7XG4gIF9mZXRjaDIgPSBmZXRjaDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlRmV0Y2hJbXBsZW1lbnRhdGlvbjIoZmV0Y2hJbXBsZW1lbnRhdGlvbikge1xuICBfZmV0Y2gyID0gZmV0Y2hJbXBsZW1lbnRhdGlvbjtcbn1cbmFzeW5jIGZ1bmN0aW9uIGZldGNoUmVsYXlJbmZvcm1hdGlvbih1cmwpIHtcbiAgcmV0dXJuIGF3YWl0IChhd2FpdCBmZXRjaCh1cmwucmVwbGFjZShcIndzOi8vXCIsIFwiaHR0cDovL1wiKS5yZXBsYWNlKFwid3NzOi8vXCIsIFwiaHR0cHM6Ly9cIiksIHtcbiAgICBoZWFkZXJzOiB7IEFjY2VwdDogXCJhcHBsaWNhdGlvbi9ub3N0citqc29uXCIgfVxuICB9KSkuanNvbigpO1xufVxuXG4vLyBuaXAxMy50c1xudmFyIG5pcDEzX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDEzX2V4cG9ydHMsIHtcbiAgZ2V0UG93OiAoKSA9PiBnZXRQb3csXG4gIG1pbmVQb3c6ICgpID0+IG1pbmVQb3dcbn0pO1xuZnVuY3Rpb24gZ2V0UG93KGhleCkge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgaGV4Lmxlbmd0aDsgaTIrKykge1xuICAgIGNvbnN0IG5pYmJsZSA9IHBhcnNlSW50KGhleFtpMl0sIDE2KTtcbiAgICBpZiAobmliYmxlID09PSAwKSB7XG4gICAgICBjb3VudCArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCArPSBNYXRoLmNsejMyKG5pYmJsZSkgLSAyODtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5mdW5jdGlvbiBtaW5lUG93KHVuc2lnbmVkLCBkaWZmaWN1bHR5KSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGNvbnN0IGV2ZW50ID0gdW5zaWduZWQ7XG4gIGNvbnN0IHRhZyA9IFtcIm5vbmNlXCIsIGNvdW50LnRvU3RyaW5nKCksIGRpZmZpY3VsdHkudG9TdHJpbmcoKV07XG4gIGV2ZW50LnRhZ3MucHVzaCh0YWcpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxZTMpO1xuICAgIGlmIChub3cgIT09IGV2ZW50LmNyZWF0ZWRfYXQpIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICAgIGV2ZW50LmNyZWF0ZWRfYXQgPSBub3c7XG4gICAgfVxuICAgIHRhZ1sxXSA9ICgrK2NvdW50KS50b1N0cmluZygpO1xuICAgIGV2ZW50LmlkID0gZ2V0RXZlbnRIYXNoKGV2ZW50KTtcbiAgICBpZiAoZ2V0UG93KGV2ZW50LmlkKSA+PSBkaWZmaWN1bHR5KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vLyBuaXAxOC50c1xudmFyIG5pcDE4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDE4X2V4cG9ydHMsIHtcbiAgZmluaXNoUmVwb3N0RXZlbnQ6ICgpID0+IGZpbmlzaFJlcG9zdEV2ZW50LFxuICBnZXRSZXBvc3RlZEV2ZW50OiAoKSA9PiBnZXRSZXBvc3RlZEV2ZW50LFxuICBnZXRSZXBvc3RlZEV2ZW50UG9pbnRlcjogKCkgPT4gZ2V0UmVwb3N0ZWRFdmVudFBvaW50ZXJcbn0pO1xuZnVuY3Rpb24gZmluaXNoUmVwb3N0RXZlbnQodCwgcmVwb3N0ZWQsIHJlbGF5VXJsLCBwcml2YXRlS2V5KSB7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIGtpbmQ6IFJlcG9zdCxcbiAgICAgIHRhZ3M6IFsuLi50LnRhZ3MgPz8gW10sIFtcImVcIiwgcmVwb3N0ZWQuaWQsIHJlbGF5VXJsXSwgW1wicFwiLCByZXBvc3RlZC5wdWJrZXldXSxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCA9PT0gXCJcIiA/IFwiXCIgOiBKU09OLnN0cmluZ2lmeShyZXBvc3RlZCksXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn1cbmZ1bmN0aW9uIGdldFJlcG9zdGVkRXZlbnRQb2ludGVyKGV2ZW50KSB7XG4gIGlmIChldmVudC5raW5kICE9PSBSZXBvc3QpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBsYXN0RVRhZztcbiAgbGV0IGxhc3RQVGFnO1xuICBmb3IgKGxldCBpMiA9IGV2ZW50LnRhZ3MubGVuZ3RoIC0gMTsgaTIgPj0gMCAmJiAobGFzdEVUYWcgPT09IHZvaWQgMCB8fCBsYXN0UFRhZyA9PT0gdm9pZCAwKTsgaTItLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICh0YWcubGVuZ3RoID49IDIpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdEVUYWcgPSB0YWc7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0UFRhZyA9IHRhZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB7XG4gICAgaWQ6IGxhc3RFVGFnWzFdLFxuICAgIHJlbGF5czogW2xhc3RFVGFnWzJdLCBsYXN0UFRhZz8uWzJdXS5maWx0ZXIoKHgpID0+IHR5cGVvZiB4ID09PSBcInN0cmluZ1wiKSxcbiAgICBhdXRob3I6IGxhc3RQVGFnPy5bMV1cbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFJlcG9zdGVkRXZlbnQoZXZlbnQsIHsgc2tpcFZlcmlmaWNhdGlvbiB9ID0ge30pIHtcbiAgY29uc3QgcG9pbnRlciA9IGdldFJlcG9zdGVkRXZlbnRQb2ludGVyKGV2ZW50KTtcbiAgaWYgKHBvaW50ZXIgPT09IHZvaWQgMCB8fCBldmVudC5jb250ZW50ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgcmVwb3N0ZWRFdmVudDtcbiAgdHJ5IHtcbiAgICByZXBvc3RlZEV2ZW50ID0gSlNPTi5wYXJzZShldmVudC5jb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChyZXBvc3RlZEV2ZW50LmlkICE9PSBwb2ludGVyLmlkKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoIXNraXBWZXJpZmljYXRpb24gJiYgIXZlcmlmeUV2ZW50KHJlcG9zdGVkRXZlbnQpKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gcmVwb3N0ZWRFdmVudDtcbn1cblxuLy8gbmlwMjEudHNcbnZhciBuaXAyMV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyMV9leHBvcnRzLCB7XG4gIE5PU1RSX1VSSV9SRUdFWDogKCkgPT4gTk9TVFJfVVJJX1JFR0VYLFxuICBwYXJzZTogKCkgPT4gcGFyc2UyLFxuICB0ZXN0OiAoKSA9PiB0ZXN0XG59KTtcbnZhciBOT1NUUl9VUklfUkVHRVggPSBuZXcgUmVnRXhwKGBub3N0cjooJHtCRUNIMzJfUkVHRVguc291cmNlfSlgKTtcbmZ1bmN0aW9uIHRlc3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiBuZXcgUmVnRXhwKGBeJHtOT1NUUl9VUklfUkVHRVguc291cmNlfSRgKS50ZXN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHBhcnNlMih1cmkpIHtcbiAgY29uc3QgbWF0Y2ggPSB1cmkubWF0Y2gobmV3IFJlZ0V4cChgXiR7Tk9TVFJfVVJJX1JFR0VYLnNvdXJjZX0kYCkpO1xuICBpZiAoIW1hdGNoKVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBOb3N0ciBVUkk6ICR7dXJpfWApO1xuICByZXR1cm4ge1xuICAgIHVyaTogbWF0Y2hbMF0sXG4gICAgdmFsdWU6IG1hdGNoWzFdLFxuICAgIGRlY29kZWQ6IGRlY29kZShtYXRjaFsxXSlcbiAgfTtcbn1cblxuLy8gbmlwMjUudHNcbnZhciBuaXAyNV9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXAyNV9leHBvcnRzLCB7XG4gIGZpbmlzaFJlYWN0aW9uRXZlbnQ6ICgpID0+IGZpbmlzaFJlYWN0aW9uRXZlbnQsXG4gIGdldFJlYWN0ZWRFdmVudFBvaW50ZXI6ICgpID0+IGdldFJlYWN0ZWRFdmVudFBvaW50ZXJcbn0pO1xuZnVuY3Rpb24gZmluaXNoUmVhY3Rpb25FdmVudCh0LCByZWFjdGVkLCBwcml2YXRlS2V5KSB7XG4gIGNvbnN0IGluaGVyaXRlZFRhZ3MgPSByZWFjdGVkLnRhZ3MuZmlsdGVyKCh0YWcpID0+IHRhZy5sZW5ndGggPj0gMiAmJiAodGFnWzBdID09PSBcImVcIiB8fCB0YWdbMF0gPT09IFwicFwiKSk7XG4gIHJldHVybiBmaW5hbGl6ZUV2ZW50KFxuICAgIHtcbiAgICAgIC4uLnQsXG4gICAgICBraW5kOiBSZWFjdGlvbixcbiAgICAgIHRhZ3M6IFsuLi50LnRhZ3MgPz8gW10sIC4uLmluaGVyaXRlZFRhZ3MsIFtcImVcIiwgcmVhY3RlZC5pZF0sIFtcInBcIiwgcmVhY3RlZC5wdWJrZXldXSxcbiAgICAgIGNvbnRlbnQ6IHQuY29udGVudCA/PyBcIitcIlxuICAgIH0sXG4gICAgcHJpdmF0ZUtleVxuICApO1xufVxuZnVuY3Rpb24gZ2V0UmVhY3RlZEV2ZW50UG9pbnRlcihldmVudCkge1xuICBpZiAoZXZlbnQua2luZCAhPT0gUmVhY3Rpb24pIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBsYXN0RVRhZztcbiAgbGV0IGxhc3RQVGFnO1xuICBmb3IgKGxldCBpMiA9IGV2ZW50LnRhZ3MubGVuZ3RoIC0gMTsgaTIgPj0gMCAmJiAobGFzdEVUYWcgPT09IHZvaWQgMCB8fCBsYXN0UFRhZyA9PT0gdm9pZCAwKTsgaTItLSkge1xuICAgIGNvbnN0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICh0YWcubGVuZ3RoID49IDIpIHtcbiAgICAgIGlmICh0YWdbMF0gPT09IFwiZVwiICYmIGxhc3RFVGFnID09PSB2b2lkIDApIHtcbiAgICAgICAgbGFzdEVUYWcgPSB0YWc7XG4gICAgICB9IGVsc2UgaWYgKHRhZ1swXSA9PT0gXCJwXCIgJiYgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgICAgICBsYXN0UFRhZyA9IHRhZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGxhc3RFVGFnID09PSB2b2lkIDAgfHwgbGFzdFBUYWcgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpZDogbGFzdEVUYWdbMV0sXG4gICAgcmVsYXlzOiBbbGFzdEVUYWdbMl0sIGxhc3RQVGFnWzJdXS5maWx0ZXIoKHgpID0+IHggIT09IHZvaWQgMCksXG4gICAgYXV0aG9yOiBsYXN0UFRhZ1sxXVxuICB9O1xufVxuXG4vLyBuaXAyNy50c1xudmFyIG5pcDI3X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI3X2V4cG9ydHMsIHtcbiAgbWF0Y2hBbGw6ICgpID0+IG1hdGNoQWxsLFxuICByZWdleDogKCkgPT4gcmVnZXgsXG4gIHJlcGxhY2VBbGw6ICgpID0+IHJlcGxhY2VBbGxcbn0pO1xudmFyIHJlZ2V4ID0gKCkgPT4gbmV3IFJlZ0V4cChgXFxcXGIke05PU1RSX1VSSV9SRUdFWC5zb3VyY2V9XFxcXGJgLCBcImdcIik7XG5mdW5jdGlvbiogbWF0Y2hBbGwoY29udGVudCkge1xuICBjb25zdCBtYXRjaGVzID0gY29udGVudC5tYXRjaEFsbChyZWdleCgpKTtcbiAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IFt1cmksIHZhbHVlXSA9IG1hdGNoO1xuICAgICAgeWllbGQge1xuICAgICAgICB1cmksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkZWNvZGVkOiBkZWNvZGUodmFsdWUpLFxuICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgIGVuZDogbWF0Y2guaW5kZXggKyB1cmkubGVuZ3RoXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXBsYWNlQWxsKGNvbnRlbnQsIHJlcGxhY2VyKSB7XG4gIHJldHVybiBjb250ZW50LnJlcGxhY2VBbGwocmVnZXgoKSwgKHVyaSwgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gcmVwbGFjZXIoe1xuICAgICAgdXJpLFxuICAgICAgdmFsdWUsXG4gICAgICBkZWNvZGVkOiBkZWNvZGUodmFsdWUpXG4gICAgfSk7XG4gIH0pO1xufVxuXG4vLyBuaXAyOC50c1xudmFyIG5pcDI4X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDI4X2V4cG9ydHMsIHtcbiAgY2hhbm5lbENyZWF0ZUV2ZW50OiAoKSA9PiBjaGFubmVsQ3JlYXRlRXZlbnQsXG4gIGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50OiAoKSA9PiBjaGFubmVsSGlkZU1lc3NhZ2VFdmVudCxcbiAgY2hhbm5lbE1lc3NhZ2VFdmVudDogKCkgPT4gY2hhbm5lbE1lc3NhZ2VFdmVudCxcbiAgY2hhbm5lbE1ldGFkYXRhRXZlbnQ6ICgpID0+IGNoYW5uZWxNZXRhZGF0YUV2ZW50LFxuICBjaGFubmVsTXV0ZVVzZXJFdmVudDogKCkgPT4gY2hhbm5lbE11dGVVc2VyRXZlbnRcbn0pO1xudmFyIGNoYW5uZWxDcmVhdGVFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGxldCBjb250ZW50O1xuICBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0LmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb250ZW50ID0gdC5jb250ZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoXG4gICAge1xuICAgICAga2luZDogQ2hhbm5lbENyZWF0aW9uLFxuICAgICAgdGFnczogWy4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNZXRhZGF0YUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTWV0YWRhdGEsXG4gICAgICB0YWdzOiBbW1wiZVwiLCB0LmNoYW5uZWxfY3JlYXRlX2V2ZW50X2lkXSwgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG52YXIgY2hhbm5lbE1lc3NhZ2VFdmVudCA9ICh0LCBwcml2YXRlS2V5KSA9PiB7XG4gIGNvbnN0IHRhZ3MgPSBbW1wiZVwiLCB0LmNoYW5uZWxfY3JlYXRlX2V2ZW50X2lkLCB0LnJlbGF5X3VybCwgXCJyb290XCJdXTtcbiAgaWYgKHQucmVwbHlfdG9fY2hhbm5lbF9tZXNzYWdlX2V2ZW50X2lkKSB7XG4gICAgdGFncy5wdXNoKFtcImVcIiwgdC5yZXBseV90b19jaGFubmVsX21lc3NhZ2VfZXZlbnRfaWQsIHQucmVsYXlfdXJsLCBcInJlcGx5XCJdKTtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTWVzc2FnZSxcbiAgICAgIHRhZ3M6IFsuLi50YWdzLCAuLi50LnRhZ3MgPz8gW11dLFxuICAgICAgY29udGVudDogdC5jb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxIaWRlTWVzc2FnZUV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsSGlkZU1lc3NhZ2UsXG4gICAgICB0YWdzOiBbW1wiZVwiLCB0LmNoYW5uZWxfbWVzc2FnZV9ldmVudF9pZF0sIC4uLnQudGFncyA/PyBbXV0sXG4gICAgICBjb250ZW50LFxuICAgICAgY3JlYXRlZF9hdDogdC5jcmVhdGVkX2F0XG4gICAgfSxcbiAgICBwcml2YXRlS2V5XG4gICk7XG59O1xudmFyIGNoYW5uZWxNdXRlVXNlckV2ZW50ID0gKHQsIHByaXZhdGVLZXkpID0+IHtcbiAgbGV0IGNvbnRlbnQ7XG4gIGlmICh0eXBlb2YgdC5jb250ZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29udGVudCA9IEpTT04uc3RyaW5naWZ5KHQuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnRlbnQgPSB0LmNvbnRlbnQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gZmluYWxpemVFdmVudChcbiAgICB7XG4gICAgICBraW5kOiBDaGFubmVsTXV0ZVVzZXIsXG4gICAgICB0YWdzOiBbW1wicFwiLCB0LnB1YmtleV90b19tdXRlXSwgLi4udC50YWdzID8/IFtdXSxcbiAgICAgIGNvbnRlbnQsXG4gICAgICBjcmVhdGVkX2F0OiB0LmNyZWF0ZWRfYXRcbiAgICB9LFxuICAgIHByaXZhdGVLZXlcbiAgKTtcbn07XG5cbi8vIG5pcDMwLnRzXG52YXIgbmlwMzBfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMzBfZXhwb3J0cywge1xuICBFTU9KSV9TSE9SVENPREVfUkVHRVg6ICgpID0+IEVNT0pJX1NIT1JUQ09ERV9SRUdFWCxcbiAgbWF0Y2hBbGw6ICgpID0+IG1hdGNoQWxsMixcbiAgcmVnZXg6ICgpID0+IHJlZ2V4MixcbiAgcmVwbGFjZUFsbDogKCkgPT4gcmVwbGFjZUFsbDJcbn0pO1xudmFyIEVNT0pJX1NIT1JUQ09ERV9SRUdFWCA9IC86KFxcdyspOi87XG52YXIgcmVnZXgyID0gKCkgPT4gbmV3IFJlZ0V4cChgXFxcXEIke0VNT0pJX1NIT1JUQ09ERV9SRUdFWC5zb3VyY2V9XFxcXEJgLCBcImdcIik7XG5mdW5jdGlvbiogbWF0Y2hBbGwyKGNvbnRlbnQpIHtcbiAgY29uc3QgbWF0Y2hlcyA9IGNvbnRlbnQubWF0Y2hBbGwocmVnZXgyKCkpO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgW3Nob3J0Y29kZSwgbmFtZV0gPSBtYXRjaDtcbiAgICAgIHlpZWxkIHtcbiAgICAgICAgc2hvcnRjb2RlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBzdGFydDogbWF0Y2guaW5kZXgsXG4gICAgICAgIGVuZDogbWF0Y2guaW5kZXggKyBzaG9ydGNvZGUubGVuZ3RoXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKF9lKSB7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXBsYWNlQWxsMihjb250ZW50LCByZXBsYWNlcikge1xuICByZXR1cm4gY29udGVudC5yZXBsYWNlQWxsKHJlZ2V4MigpLCAoc2hvcnRjb2RlLCBuYW1lKSA9PiB7XG4gICAgcmV0dXJuIHJlcGxhY2VyKHtcbiAgICAgIHNob3J0Y29kZSxcbiAgICAgIG5hbWVcbiAgICB9KTtcbiAgfSk7XG59XG5cbi8vIG5pcDM5LnRzXG52YXIgbmlwMzlfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobmlwMzlfZXhwb3J0cywge1xuICB1c2VGZXRjaEltcGxlbWVudGF0aW9uOiAoKSA9PiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMyxcbiAgdmFsaWRhdGVHaXRodWI6ICgpID0+IHZhbGlkYXRlR2l0aHViXG59KTtcbnZhciBfZmV0Y2gzO1xudHJ5IHtcbiAgX2ZldGNoMyA9IGZldGNoO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1c2VGZXRjaEltcGxlbWVudGF0aW9uMyhmZXRjaEltcGxlbWVudGF0aW9uKSB7XG4gIF9mZXRjaDMgPSBmZXRjaEltcGxlbWVudGF0aW9uO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVHaXRodWIocHVia2V5LCB1c2VybmFtZSwgcHJvb2YpIHtcbiAgdHJ5IHtcbiAgICBsZXQgcmVzID0gYXdhaXQgKGF3YWl0IF9mZXRjaDMoYGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLyR7dXNlcm5hbWV9LyR7cHJvb2Z9L3Jhd2ApKS50ZXh0KCk7XG4gICAgcmV0dXJuIHJlcyA9PT0gYFZlcmlmeWluZyB0aGF0IEkgY29udHJvbCB0aGUgZm9sbG93aW5nIE5vc3RyIHB1YmxpYyBrZXk6ICR7cHVia2V5fWA7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gbmlwNDQudHNcbnZhciBuaXA0NF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA0NF9leHBvcnRzLCB7XG4gIGRlY3J5cHQ6ICgpID0+IGRlY3J5cHQyLFxuICBlbmNyeXB0OiAoKSA9PiBlbmNyeXB0MixcbiAgZ2V0Q29udmVyc2F0aW9uS2V5OiAoKSA9PiBnZXRDb252ZXJzYXRpb25LZXksXG4gIHYyOiAoKSA9PiB2MlxufSk7XG5pbXBvcnQgeyBjaGFjaGEyMCB9IGZyb20gXCJAbm9ibGUvY2lwaGVycy9jaGFjaGFcIjtcbmltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tIFwiQG5vYmxlL2NpcGhlcnMvdXRpbHNcIjtcbmltcG9ydCB7IHNlY3AyNTZrMSBhcyBzZWNwMjU2azEyIH0gZnJvbSBcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCI7XG5pbXBvcnQgeyBleHRyYWN0IGFzIGhrZGZfZXh0cmFjdCwgZXhwYW5kIGFzIGhrZGZfZXhwYW5kIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvaGtkZlwiO1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL2htYWNcIjtcbmltcG9ydCB7IHNoYTI1NiBhcyBzaGEyNTYyIH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5pbXBvcnQgeyBjb25jYXRCeXRlcyBhcyBjb25jYXRCeXRlczIsIHJhbmRvbUJ5dGVzIGFzIHJhbmRvbUJ5dGVzMiB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiYXNlNjQgYXMgYmFzZTY0MiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIG1pblBsYWludGV4dFNpemUgPSAxO1xudmFyIG1heFBsYWludGV4dFNpemUgPSA2NTUzNTtcbmZ1bmN0aW9uIGdldENvbnZlcnNhdGlvbktleShwcml2a2V5QSwgcHVia2V5Qikge1xuICBjb25zdCBzaGFyZWRYID0gc2VjcDI1NmsxMi5nZXRTaGFyZWRTZWNyZXQocHJpdmtleUEsIFwiMDJcIiArIHB1YmtleUIpLnN1YmFycmF5KDEsIDMzKTtcbiAgcmV0dXJuIGhrZGZfZXh0cmFjdChzaGEyNTYyLCBzaGFyZWRYLCBcIm5pcDQ0LXYyXCIpO1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZUtleXMoY29udmVyc2F0aW9uS2V5LCBub25jZSkge1xuICBjb25zdCBrZXlzID0gaGtkZl9leHBhbmQoc2hhMjU2MiwgY29udmVyc2F0aW9uS2V5LCBub25jZSwgNzYpO1xuICByZXR1cm4ge1xuICAgIGNoYWNoYV9rZXk6IGtleXMuc3ViYXJyYXkoMCwgMzIpLFxuICAgIGNoYWNoYV9ub25jZToga2V5cy5zdWJhcnJheSgzMiwgNDQpLFxuICAgIGhtYWNfa2V5OiBrZXlzLnN1YmFycmF5KDQ0LCA3NilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNhbGNQYWRkZWRMZW4obGVuKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobGVuKSB8fCBsZW4gPCAxKVxuICAgIHRocm93IG5ldyBFcnJvcihcImV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJcIik7XG4gIGlmIChsZW4gPD0gMzIpXG4gICAgcmV0dXJuIDMyO1xuICBjb25zdCBuZXh0UG93ZXIgPSAxIDw8IE1hdGguZmxvb3IoTWF0aC5sb2cyKGxlbiAtIDEpKSArIDE7XG4gIGNvbnN0IGNodW5rID0gbmV4dFBvd2VyIDw9IDI1NiA/IDMyIDogbmV4dFBvd2VyIC8gODtcbiAgcmV0dXJuIGNodW5rICogKE1hdGguZmxvb3IoKGxlbiAtIDEpIC8gY2h1bmspICsgMSk7XG59XG5mdW5jdGlvbiB3cml0ZVUxNkJFKG51bSkge1xuICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG51bSkgfHwgbnVtIDwgbWluUGxhaW50ZXh0U2l6ZSB8fCBudW0gPiBtYXhQbGFpbnRleHRTaXplKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGxhaW50ZXh0IHNpemU6IG11c3QgYmUgYmV0d2VlbiAxIGFuZCA2NTUzNSBieXRlc1wiKTtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMik7XG4gIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyKS5zZXRVaW50MTYoMCwgbnVtLCBmYWxzZSk7XG4gIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBwYWQocGxhaW50ZXh0KSB7XG4gIGNvbnN0IHVucGFkZGVkID0gdXRmOEVuY29kZXIuZW5jb2RlKHBsYWludGV4dCk7XG4gIGNvbnN0IHVucGFkZGVkTGVuID0gdW5wYWRkZWQubGVuZ3RoO1xuICBjb25zdCBwcmVmaXggPSB3cml0ZVUxNkJFKHVucGFkZGVkTGVuKTtcbiAgY29uc3Qgc3VmZml4ID0gbmV3IFVpbnQ4QXJyYXkoY2FsY1BhZGRlZExlbih1bnBhZGRlZExlbikgLSB1bnBhZGRlZExlbik7XG4gIHJldHVybiBjb25jYXRCeXRlczIocHJlZml4LCB1bnBhZGRlZCwgc3VmZml4KTtcbn1cbmZ1bmN0aW9uIHVucGFkKHBhZGRlZCkge1xuICBjb25zdCB1bnBhZGRlZExlbiA9IG5ldyBEYXRhVmlldyhwYWRkZWQuYnVmZmVyKS5nZXRVaW50MTYoMCk7XG4gIGNvbnN0IHVucGFkZGVkID0gcGFkZGVkLnN1YmFycmF5KDIsIDIgKyB1bnBhZGRlZExlbik7XG4gIGlmICh1bnBhZGRlZExlbiA8IG1pblBsYWludGV4dFNpemUgfHwgdW5wYWRkZWRMZW4gPiBtYXhQbGFpbnRleHRTaXplIHx8IHVucGFkZGVkLmxlbmd0aCAhPT0gdW5wYWRkZWRMZW4gfHwgcGFkZGVkLmxlbmd0aCAhPT0gMiArIGNhbGNQYWRkZWRMZW4odW5wYWRkZWRMZW4pKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFkZGluZ1wiKTtcbiAgcmV0dXJuIHV0ZjhEZWNvZGVyLmRlY29kZSh1bnBhZGRlZCk7XG59XG5mdW5jdGlvbiBobWFjQWFkKGtleSwgbWVzc2FnZSwgYWFkKSB7XG4gIGlmIChhYWQubGVuZ3RoICE9PSAzMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBQUQgYXNzb2NpYXRlZCBkYXRhIG11c3QgYmUgMzIgYnl0ZXNcIik7XG4gIGNvbnN0IGNvbWJpbmVkID0gY29uY2F0Qnl0ZXMyKGFhZCwgbWVzc2FnZSk7XG4gIHJldHVybiBobWFjKHNoYTI1NjIsIGtleSwgY29tYmluZWQpO1xufVxuZnVuY3Rpb24gZGVjb2RlUGF5bG9hZChwYXlsb2FkKSB7XG4gIGlmICh0eXBlb2YgcGF5bG9hZCAhPT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwYXlsb2FkIG11c3QgYmUgYSB2YWxpZCBzdHJpbmdcIik7XG4gIGNvbnN0IHBsZW4gPSBwYXlsb2FkLmxlbmd0aDtcbiAgaWYgKHBsZW4gPCAxMzIgfHwgcGxlbiA+IDg3NDcyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF5bG9hZCBsZW5ndGg6IFwiICsgcGxlbik7XG4gIGlmIChwYXlsb2FkWzBdID09PSBcIiNcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIGVuY3J5cHRpb24gdmVyc2lvblwiKTtcbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IGJhc2U2NDIuZGVjb2RlKHBheWxvYWQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmFzZTY0OiBcIiArIGVycm9yLm1lc3NhZ2UpO1xuICB9XG4gIGNvbnN0IGRsZW4gPSBkYXRhLmxlbmd0aDtcbiAgaWYgKGRsZW4gPCA5OSB8fCBkbGVuID4gNjU2MDMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhIGxlbmd0aDogXCIgKyBkbGVuKTtcbiAgY29uc3QgdmVycyA9IGRhdGFbMF07XG4gIGlmICh2ZXJzICE9PSAyKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gZW5jcnlwdGlvbiB2ZXJzaW9uIFwiICsgdmVycyk7XG4gIHJldHVybiB7XG4gICAgbm9uY2U6IGRhdGEuc3ViYXJyYXkoMSwgMzMpLFxuICAgIGNpcGhlcnRleHQ6IGRhdGEuc3ViYXJyYXkoMzMsIC0zMiksXG4gICAgbWFjOiBkYXRhLnN1YmFycmF5KC0zMilcbiAgfTtcbn1cbmZ1bmN0aW9uIGVuY3J5cHQyKHBsYWludGV4dCwgY29udmVyc2F0aW9uS2V5LCBub25jZSA9IHJhbmRvbUJ5dGVzMigzMikpIHtcbiAgY29uc3QgeyBjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIGhtYWNfa2V5IH0gPSBnZXRNZXNzYWdlS2V5cyhjb252ZXJzYXRpb25LZXksIG5vbmNlKTtcbiAgY29uc3QgcGFkZGVkID0gcGFkKHBsYWludGV4dCk7XG4gIGNvbnN0IGNpcGhlcnRleHQgPSBjaGFjaGEyMChjaGFjaGFfa2V5LCBjaGFjaGFfbm9uY2UsIHBhZGRlZCk7XG4gIGNvbnN0IG1hYyA9IGhtYWNBYWQoaG1hY19rZXksIGNpcGhlcnRleHQsIG5vbmNlKTtcbiAgcmV0dXJuIGJhc2U2NDIuZW5jb2RlKGNvbmNhdEJ5dGVzMihuZXcgVWludDhBcnJheShbMl0pLCBub25jZSwgY2lwaGVydGV4dCwgbWFjKSk7XG59XG5mdW5jdGlvbiBkZWNyeXB0MihwYXlsb2FkLCBjb252ZXJzYXRpb25LZXkpIHtcbiAgY29uc3QgeyBub25jZSwgY2lwaGVydGV4dCwgbWFjIH0gPSBkZWNvZGVQYXlsb2FkKHBheWxvYWQpO1xuICBjb25zdCB7IGNoYWNoYV9rZXksIGNoYWNoYV9ub25jZSwgaG1hY19rZXkgfSA9IGdldE1lc3NhZ2VLZXlzKGNvbnZlcnNhdGlvbktleSwgbm9uY2UpO1xuICBjb25zdCBjYWxjdWxhdGVkTWFjID0gaG1hY0FhZChobWFjX2tleSwgY2lwaGVydGV4dCwgbm9uY2UpO1xuICBpZiAoIWVxdWFsQnl0ZXMoY2FsY3VsYXRlZE1hYywgbWFjKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIE1BQ1wiKTtcbiAgY29uc3QgcGFkZGVkID0gY2hhY2hhMjAoY2hhY2hhX2tleSwgY2hhY2hhX25vbmNlLCBjaXBoZXJ0ZXh0KTtcbiAgcmV0dXJuIHVucGFkKHBhZGRlZCk7XG59XG52YXIgdjIgPSB7XG4gIHV0aWxzOiB7XG4gICAgZ2V0Q29udmVyc2F0aW9uS2V5LFxuICAgIGNhbGNQYWRkZWRMZW5cbiAgfSxcbiAgZW5jcnlwdDogZW5jcnlwdDIsXG4gIGRlY3J5cHQ6IGRlY3J5cHQyXG59O1xuXG4vLyBuaXA0Ny50c1xudmFyIG5pcDQ3X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG5pcDQ3X2V4cG9ydHMsIHtcbiAgbWFrZU53Y1JlcXVlc3RFdmVudDogKCkgPT4gbWFrZU53Y1JlcXVlc3RFdmVudCxcbiAgcGFyc2VDb25uZWN0aW9uU3RyaW5nOiAoKSA9PiBwYXJzZUNvbm5lY3Rpb25TdHJpbmdcbn0pO1xuZnVuY3Rpb24gcGFyc2VDb25uZWN0aW9uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoUGFyYW1zIH0gPSBuZXcgVVJMKGNvbm5lY3Rpb25TdHJpbmcpO1xuICBjb25zdCBwdWJrZXkgPSBwYXRobmFtZTtcbiAgY29uc3QgcmVsYXkgPSBzZWFyY2hQYXJhbXMuZ2V0KFwicmVsYXlcIik7XG4gIGNvbnN0IHNlY3JldCA9IHNlYXJjaFBhcmFtcy5nZXQoXCJzZWNyZXRcIik7XG4gIGlmICghcHVia2V5IHx8ICFyZWxheSB8fCAhc2VjcmV0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjb25uZWN0aW9uIHN0cmluZ1wiKTtcbiAgfVxuICByZXR1cm4geyBwdWJrZXksIHJlbGF5LCBzZWNyZXQgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG1ha2VOd2NSZXF1ZXN0RXZlbnQocHVia2V5LCBzZWNyZXRLZXksIGludm9pY2UpIHtcbiAgY29uc3QgY29udGVudCA9IHtcbiAgICBtZXRob2Q6IFwicGF5X2ludm9pY2VcIixcbiAgICBwYXJhbXM6IHtcbiAgICAgIGludm9pY2VcbiAgICB9XG4gIH07XG4gIGNvbnN0IGVuY3J5cHRlZENvbnRlbnQgPSBhd2FpdCBlbmNyeXB0KHNlY3JldEtleSwgcHVia2V5LCBKU09OLnN0cmluZ2lmeShjb250ZW50KSk7XG4gIGNvbnN0IGV2ZW50VGVtcGxhdGUgPSB7XG4gICAga2luZDogTldDV2FsbGV0UmVxdWVzdCxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMpLFxuICAgIGNvbnRlbnQ6IGVuY3J5cHRlZENvbnRlbnQsXG4gICAgdGFnczogW1tcInBcIiwgcHVia2V5XV1cbiAgfTtcbiAgcmV0dXJuIGZpbmFsaXplRXZlbnQoZXZlbnRUZW1wbGF0ZSwgc2VjcmV0S2V5KTtcbn1cblxuLy8gbmlwNTcudHNcbnZhciBuaXA1N19leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA1N19leHBvcnRzLCB7XG4gIGdldFphcEVuZHBvaW50OiAoKSA9PiBnZXRaYXBFbmRwb2ludCxcbiAgbWFrZVphcFJlY2VpcHQ6ICgpID0+IG1ha2VaYXBSZWNlaXB0LFxuICBtYWtlWmFwUmVxdWVzdDogKCkgPT4gbWFrZVphcFJlcXVlc3QsXG4gIHVzZUZldGNoSW1wbGVtZW50YXRpb246ICgpID0+IHVzZUZldGNoSW1wbGVtZW50YXRpb240LFxuICB2YWxpZGF0ZVphcFJlcXVlc3Q6ICgpID0+IHZhbGlkYXRlWmFwUmVxdWVzdFxufSk7XG5pbXBvcnQgeyBiZWNoMzIgYXMgYmVjaDMyMiB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIF9mZXRjaDQ7XG50cnkge1xuICBfZmV0Y2g0ID0gZmV0Y2g7XG59IGNhdGNoIHtcbn1cbmZ1bmN0aW9uIHVzZUZldGNoSW1wbGVtZW50YXRpb240KGZldGNoSW1wbGVtZW50YXRpb24pIHtcbiAgX2ZldGNoNCA9IGZldGNoSW1wbGVtZW50YXRpb247XG59XG5hc3luYyBmdW5jdGlvbiBnZXRaYXBFbmRwb2ludChtZXRhZGF0YSkge1xuICB0cnkge1xuICAgIGxldCBsbnVybCA9IFwiXCI7XG4gICAgbGV0IHsgbHVkMDYsIGx1ZDE2IH0gPSBKU09OLnBhcnNlKG1ldGFkYXRhLmNvbnRlbnQpO1xuICAgIGlmIChsdWQwNikge1xuICAgICAgbGV0IHsgd29yZHMgfSA9IGJlY2gzMjIuZGVjb2RlKGx1ZDA2LCAxZTMpO1xuICAgICAgbGV0IGRhdGEgPSBiZWNoMzIyLmZyb21Xb3Jkcyh3b3Jkcyk7XG4gICAgICBsbnVybCA9IHV0ZjhEZWNvZGVyLmRlY29kZShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKGx1ZDE2KSB7XG4gICAgICBsZXQgW25hbWUsIGRvbWFpbl0gPSBsdWQxNi5zcGxpdChcIkBcIik7XG4gICAgICBsbnVybCA9IG5ldyBVUkwoYC8ud2VsbC1rbm93bi9sbnVybHAvJHtuYW1lfWAsIGBodHRwczovLyR7ZG9tYWlufWApLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgcmVzID0gYXdhaXQgX2ZldGNoNChsbnVybCk7XG4gICAgbGV0IGJvZHkgPSBhd2FpdCByZXMuanNvbigpO1xuICAgIGlmIChib2R5LmFsbG93c05vc3RyICYmIGJvZHkubm9zdHJQdWJrZXkpIHtcbiAgICAgIHJldHVybiBib2R5LmNhbGxiYWNrO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYWtlWmFwUmVxdWVzdCh7XG4gIHByb2ZpbGUsXG4gIGV2ZW50LFxuICBhbW91bnQsXG4gIHJlbGF5cyxcbiAgY29tbWVudCA9IFwiXCJcbn0pIHtcbiAgaWYgKCFhbW91bnQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYW1vdW50IG5vdCBnaXZlblwiKTtcbiAgaWYgKCFwcm9maWxlKVxuICAgIHRocm93IG5ldyBFcnJvcihcInByb2ZpbGUgbm90IGdpdmVuXCIpO1xuICBsZXQgenIgPSB7XG4gICAga2luZDogOTczNCxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxZTMpLFxuICAgIGNvbnRlbnQ6IGNvbW1lbnQsXG4gICAgdGFnczogW1xuICAgICAgW1wicFwiLCBwcm9maWxlXSxcbiAgICAgIFtcImFtb3VudFwiLCBhbW91bnQudG9TdHJpbmcoKV0sXG4gICAgICBbXCJyZWxheXNcIiwgLi4ucmVsYXlzXVxuICAgIF1cbiAgfTtcbiAgaWYgKGV2ZW50KSB7XG4gICAgenIudGFncy5wdXNoKFtcImVcIiwgZXZlbnRdKTtcbiAgfVxuICByZXR1cm4genI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVphcFJlcXVlc3QoemFwUmVxdWVzdFN0cmluZykge1xuICBsZXQgemFwUmVxdWVzdDtcbiAgdHJ5IHtcbiAgICB6YXBSZXF1ZXN0ID0gSlNPTi5wYXJzZSh6YXBSZXF1ZXN0U3RyaW5nKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFwiSW52YWxpZCB6YXAgcmVxdWVzdCBKU09OLlwiO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudCh6YXBSZXF1ZXN0KSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCBpcyBub3QgYSB2YWxpZCBOb3N0ciBldmVudC5cIjtcbiAgaWYgKCF2ZXJpZnlFdmVudCh6YXBSZXF1ZXN0KSlcbiAgICByZXR1cm4gXCJJbnZhbGlkIHNpZ25hdHVyZSBvbiB6YXAgcmVxdWVzdC5cIjtcbiAgbGV0IHAgPSB6YXBSZXF1ZXN0LnRhZ3MuZmluZCgoW3QsIHZdKSA9PiB0ID09PSBcInBcIiAmJiB2KTtcbiAgaWYgKCFwKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0IGRvZXNuJ3QgaGF2ZSBhICdwJyB0YWcuXCI7XG4gIGlmICghcFsxXS5tYXRjaCgvXlthLWYwLTldezY0fSQvKSlcbiAgICByZXR1cm4gXCJaYXAgcmVxdWVzdCAncCcgdGFnIGlzIG5vdCB2YWxpZCBoZXguXCI7XG4gIGxldCBlID0gemFwUmVxdWVzdC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gXCJlXCIgJiYgdik7XG4gIGlmIChlICYmICFlWzFdLm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0ICdlJyB0YWcgaXMgbm90IHZhbGlkIGhleC5cIjtcbiAgbGV0IHJlbGF5cyA9IHphcFJlcXVlc3QudGFncy5maW5kKChbdCwgdl0pID0+IHQgPT09IFwicmVsYXlzXCIgJiYgdik7XG4gIGlmICghcmVsYXlzKVxuICAgIHJldHVybiBcIlphcCByZXF1ZXN0IGRvZXNuJ3QgaGF2ZSBhICdyZWxheXMnIHRhZy5cIjtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBtYWtlWmFwUmVjZWlwdCh7XG4gIHphcFJlcXVlc3QsXG4gIHByZWltYWdlLFxuICBib2x0MTEsXG4gIHBhaWRBdFxufSkge1xuICBsZXQgenIgPSBKU09OLnBhcnNlKHphcFJlcXVlc3QpO1xuICBsZXQgdGFnc0Zyb21aYXBSZXF1ZXN0ID0genIudGFncy5maWx0ZXIoKFt0XSkgPT4gdCA9PT0gXCJlXCIgfHwgdCA9PT0gXCJwXCIgfHwgdCA9PT0gXCJhXCIpO1xuICBsZXQgemFwID0ge1xuICAgIGtpbmQ6IDk3MzUsXG4gICAgY3JlYXRlZF9hdDogTWF0aC5yb3VuZChwYWlkQXQuZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiLFxuICAgIHRhZ3M6IFsuLi50YWdzRnJvbVphcFJlcXVlc3QsIFtcIlBcIiwgenIucHVia2V5XSwgW1wiYm9sdDExXCIsIGJvbHQxMV0sIFtcImRlc2NyaXB0aW9uXCIsIHphcFJlcXVlc3RdXVxuICB9O1xuICBpZiAocHJlaW1hZ2UpIHtcbiAgICB6YXAudGFncy5wdXNoKFtcInByZWltYWdlXCIsIHByZWltYWdlXSk7XG4gIH1cbiAgcmV0dXJuIHphcDtcbn1cblxuLy8gbmlwOTgudHNcbnZhciBuaXA5OF9leHBvcnRzID0ge307XG5fX2V4cG9ydChuaXA5OF9leHBvcnRzLCB7XG4gIGdldFRva2VuOiAoKSA9PiBnZXRUb2tlbixcbiAgaGFzaFBheWxvYWQ6ICgpID0+IGhhc2hQYXlsb2FkLFxuICB1bnBhY2tFdmVudEZyb21Ub2tlbjogKCkgPT4gdW5wYWNrRXZlbnRGcm9tVG9rZW4sXG4gIHZhbGlkYXRlRXZlbnQ6ICgpID0+IHZhbGlkYXRlRXZlbnQyLFxuICB2YWxpZGF0ZUV2ZW50S2luZDogKCkgPT4gdmFsaWRhdGVFdmVudEtpbmQsXG4gIHZhbGlkYXRlRXZlbnRNZXRob2RUYWc6ICgpID0+IHZhbGlkYXRlRXZlbnRNZXRob2RUYWcsXG4gIHZhbGlkYXRlRXZlbnRQYXlsb2FkVGFnOiAoKSA9PiB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyxcbiAgdmFsaWRhdGVFdmVudFRpbWVzdGFtcDogKCkgPT4gdmFsaWRhdGVFdmVudFRpbWVzdGFtcCxcbiAgdmFsaWRhdGVFdmVudFVybFRhZzogKCkgPT4gdmFsaWRhdGVFdmVudFVybFRhZyxcbiAgdmFsaWRhdGVUb2tlbjogKCkgPT4gdmFsaWRhdGVUb2tlblxufSk7XG5pbXBvcnQgeyBzaGEyNTYgYXMgc2hhMjU2MyB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4NCB9IGZyb20gXCJAbm9ibGUvaGFzaGVzL3V0aWxzXCI7XG5pbXBvcnQgeyBiYXNlNjQgYXMgYmFzZTY0MyB9IGZyb20gXCJAc2N1cmUvYmFzZVwiO1xudmFyIF9hdXRob3JpemF0aW9uU2NoZW1lID0gXCJOb3N0ciBcIjtcbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuKGxvZ2luVXJsLCBodHRwTWV0aG9kLCBzaWduLCBpbmNsdWRlQXV0aG9yaXphdGlvblNjaGVtZSA9IGZhbHNlLCBwYXlsb2FkKSB7XG4gIGNvbnN0IGV2ZW50ID0ge1xuICAgIGtpbmQ6IEhUVFBBdXRoLFxuICAgIHRhZ3M6IFtcbiAgICAgIFtcInVcIiwgbG9naW5VcmxdLFxuICAgICAgW1wibWV0aG9kXCIsIGh0dHBNZXRob2RdXG4gICAgXSxcbiAgICBjcmVhdGVkX2F0OiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSxcbiAgICBjb250ZW50OiBcIlwiXG4gIH07XG4gIGlmIChwYXlsb2FkKSB7XG4gICAgZXZlbnQudGFncy5wdXNoKFtcInBheWxvYWRcIiwgaGFzaFBheWxvYWQocGF5bG9hZCldKTtcbiAgfVxuICBjb25zdCBzaWduZWRFdmVudCA9IGF3YWl0IHNpZ24oZXZlbnQpO1xuICBjb25zdCBhdXRob3JpemF0aW9uU2NoZW1lID0gaW5jbHVkZUF1dGhvcml6YXRpb25TY2hlbWUgPyBfYXV0aG9yaXphdGlvblNjaGVtZSA6IFwiXCI7XG4gIHJldHVybiBhdXRob3JpemF0aW9uU2NoZW1lICsgYmFzZTY0My5lbmNvZGUodXRmOEVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHNpZ25lZEV2ZW50KSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVUb2tlbih0b2tlbiwgdXJsLCBtZXRob2QpIHtcbiAgY29uc3QgZXZlbnQgPSBhd2FpdCB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICBjb25zdCB2YWxpZCA9IGF3YWl0IHZhbGlkYXRlRXZlbnQyKGV2ZW50LCB1cmwsIG1ldGhvZCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0pO1xuICByZXR1cm4gdmFsaWQ7XG59XG5hc3luYyBmdW5jdGlvbiB1bnBhY2tFdmVudEZyb21Ub2tlbih0b2tlbikge1xuICBpZiAoIXRva2VuKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB0b2tlblwiKTtcbiAgfVxuICB0b2tlbiA9IHRva2VuLnJlcGxhY2UoX2F1dGhvcml6YXRpb25TY2hlbWUsIFwiXCIpO1xuICBjb25zdCBldmVudEI2NCA9IHV0ZjhEZWNvZGVyLmRlY29kZShiYXNlNjQzLmRlY29kZSh0b2tlbikpO1xuICBpZiAoIWV2ZW50QjY0IHx8IGV2ZW50QjY0Lmxlbmd0aCA9PT0gMCB8fCAhZXZlbnRCNjQuc3RhcnRzV2l0aChcIntcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHRva2VuXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50ID0gSlNPTi5wYXJzZShldmVudEI2NCk7XG4gIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRUaW1lc3RhbXAoZXZlbnQpIHtcbiAgaWYgKCFldmVudC5jcmVhdGVkX2F0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMWUzKSAtIGV2ZW50LmNyZWF0ZWRfYXQgPCA2MDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRLaW5kKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5raW5kID09PSBIVFRQQXV0aDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnRVcmxUYWcoZXZlbnQsIHVybCkge1xuICBjb25zdCB1cmxUYWcgPSBldmVudC50YWdzLmZpbmQoKHQpID0+IHRbMF0gPT09IFwidVwiKTtcbiAgaWYgKCF1cmxUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHVybFRhZy5sZW5ndGggPiAwICYmIHVybFRhZ1sxXSA9PT0gdXJsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSB7XG4gIGNvbnN0IG1ldGhvZFRhZyA9IGV2ZW50LnRhZ3MuZmluZCgodCkgPT4gdFswXSA9PT0gXCJtZXRob2RcIik7XG4gIGlmICghbWV0aG9kVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBtZXRob2RUYWcubGVuZ3RoID4gMCAmJiBtZXRob2RUYWdbMV0udG9Mb3dlckNhc2UoKSA9PT0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBoYXNoUGF5bG9hZChwYXlsb2FkKSB7XG4gIGNvbnN0IGhhc2ggPSBzaGEyNTYzKHV0ZjhFbmNvZGVyLmVuY29kZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSkpO1xuICByZXR1cm4gYnl0ZXNUb0hleDQoaGFzaCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgcGF5bG9hZCkge1xuICBjb25zdCBwYXlsb2FkVGFnID0gZXZlbnQudGFncy5maW5kKCh0KSA9PiB0WzBdID09PSBcInBheWxvYWRcIik7XG4gIGlmICghcGF5bG9hZFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBwYXlsb2FkSGFzaCA9IGhhc2hQYXlsb2FkKHBheWxvYWQpO1xuICByZXR1cm4gcGF5bG9hZFRhZy5sZW5ndGggPiAwICYmIHBheWxvYWRUYWdbMV0gPT09IHBheWxvYWRIYXNoO1xufVxuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVFdmVudDIoZXZlbnQsIHVybCwgbWV0aG9kLCBib2R5KSB7XG4gIGlmICghdmVyaWZ5RXZlbnQoZXZlbnQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgc2lnbmF0dXJlIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50S2luZChldmVudCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vc3RyIGV2ZW50LCBraW5kIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VGltZXN0YW1wKGV2ZW50KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIGNyZWF0ZWRfYXQgdGltZXN0YW1wIGludmFsaWRcIik7XG4gIH1cbiAgaWYgKCF2YWxpZGF0ZUV2ZW50VXJsVGFnKGV2ZW50LCB1cmwpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBub3N0ciBldmVudCwgdXJsIHRhZyBpbnZhbGlkXCIpO1xuICB9XG4gIGlmICghdmFsaWRhdGVFdmVudE1ldGhvZFRhZyhldmVudCwgbWV0aG9kKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIG1ldGhvZCB0YWcgaW52YWxpZFwiKTtcbiAgfVxuICBpZiAoQm9vbGVhbihib2R5KSAmJiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhib2R5KS5sZW5ndGggPiAwKSB7XG4gICAgaWYgKCF2YWxpZGF0ZUV2ZW50UGF5bG9hZFRhZyhldmVudCwgYm9keSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbm9zdHIgZXZlbnQsIHBheWxvYWQgdGFnIGRvZXMgbm90IG1hdGNoIHJlcXVlc3QgYm9keSBoYXNoXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCB7XG4gIFJlbGF5LFxuICBTaW1wbGVQb29sLFxuICBmaW5hbGl6ZUV2ZW50LFxuICBmYWtlanNvbl9leHBvcnRzIGFzIGZqLFxuICBnZW5lcmF0ZVNlY3JldEtleSxcbiAgZ2V0RXZlbnRIYXNoLFxuICBnZXRGaWx0ZXJMaW1pdCxcbiAgZ2V0UHVibGljS2V5LFxuICBraW5kc19leHBvcnRzIGFzIGtpbmRzLFxuICBtYXRjaEZpbHRlcixcbiAgbWF0Y2hGaWx0ZXJzLFxuICBtZXJnZUZpbHRlcnMsXG4gIG5pcDA0X2V4cG9ydHMgYXMgbmlwMDQsXG4gIG5pcDA1X2V4cG9ydHMgYXMgbmlwMDUsXG4gIG5pcDEwX2V4cG9ydHMgYXMgbmlwMTAsXG4gIG5pcDExX2V4cG9ydHMgYXMgbmlwMTEsXG4gIG5pcDEzX2V4cG9ydHMgYXMgbmlwMTMsXG4gIG5pcDE4X2V4cG9ydHMgYXMgbmlwMTgsXG4gIG5pcDE5X2V4cG9ydHMgYXMgbmlwMTksXG4gIG5pcDIxX2V4cG9ydHMgYXMgbmlwMjEsXG4gIG5pcDI1X2V4cG9ydHMgYXMgbmlwMjUsXG4gIG5pcDI3X2V4cG9ydHMgYXMgbmlwMjcsXG4gIG5pcDI4X2V4cG9ydHMgYXMgbmlwMjgsXG4gIG5pcDMwX2V4cG9ydHMgYXMgbmlwMzAsXG4gIG5pcDM5X2V4cG9ydHMgYXMgbmlwMzksXG4gIG5pcDQyX2V4cG9ydHMgYXMgbmlwNDIsXG4gIG5pcDQ0X2V4cG9ydHMgYXMgbmlwNDQsXG4gIG5pcDQ3X2V4cG9ydHMgYXMgbmlwNDcsXG4gIG5pcDU3X2V4cG9ydHMgYXMgbmlwNTcsXG4gIG5pcDk4X2V4cG9ydHMgYXMgbmlwOTgsXG4gIHBhcnNlUmVmZXJlbmNlcyxcbiAgc2VyaWFsaXplRXZlbnQsXG4gIHNvcnRFdmVudHMsXG4gIHV0aWxzX2V4cG9ydHMgYXMgdXRpbHMsXG4gIHZhbGlkYXRlRXZlbnQsXG4gIHZlcmlmaWVkU3ltYm9sLFxuICB2ZXJpZnlFdmVudFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nostr-tools/lib/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/nostr-tools/lib/esm/pool.js":
/*!**************************************************!*\
  !*** ./node_modules/nostr-tools/lib/esm/pool.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractSimplePool: () => (/* binding */ AbstractSimplePool),\n/* harmony export */   SimplePool: () => (/* binding */ SimplePool),\n/* harmony export */   useWebSocketImplementation: () => (/* binding */ useWebSocketImplementation)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(ssr)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils */ \"(ssr)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/esm/sha256.js\");\n// pure.ts\n\n\n\n// core.ts\nvar verifiedSymbol = Symbol(\"verified\");\nvar isRecord = (obj) => obj instanceof Object;\nfunction validateEvent(event) {\n  if (!isRecord(event))\n    return false;\n  if (typeof event.kind !== \"number\")\n    return false;\n  if (typeof event.content !== \"string\")\n    return false;\n  if (typeof event.created_at !== \"number\")\n    return false;\n  if (typeof event.pubkey !== \"string\")\n    return false;\n  if (!event.pubkey.match(/^[a-f0-9]{64}$/))\n    return false;\n  if (!Array.isArray(event.tags))\n    return false;\n  for (let i2 = 0; i2 < event.tags.length; i2++) {\n    let tag = event.tags[i2];\n    if (!Array.isArray(tag))\n      return false;\n    for (let j = 0; j < tag.length; j++) {\n      if (typeof tag[j] === \"object\")\n        return false;\n    }\n  }\n  return true;\n}\n\n// pure.ts\n\n\n// utils.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nvar utf8Encoder = new TextEncoder();\nfunction normalizeURL(url) {\n  if (url.indexOf(\"://\") === -1)\n    url = \"wss://\" + url;\n  let p = new URL(url);\n  p.pathname = p.pathname.replace(/\\/+/g, \"/\");\n  if (p.pathname.endsWith(\"/\"))\n    p.pathname = p.pathname.slice(0, -1);\n  if (p.port === \"80\" && p.protocol === \"ws:\" || p.port === \"443\" && p.protocol === \"wss:\")\n    p.port = \"\";\n  p.searchParams.sort();\n  p.hash = \"\";\n  return p.toString();\n}\nvar QueueNode = class {\n  value;\n  next = null;\n  prev = null;\n  constructor(message) {\n    this.value = message;\n  }\n};\nvar Queue = class {\n  first;\n  last;\n  constructor() {\n    this.first = null;\n    this.last = null;\n  }\n  enqueue(value) {\n    const newNode = new QueueNode(value);\n    if (!this.last) {\n      this.first = newNode;\n      this.last = newNode;\n    } else if (this.last === this.first) {\n      this.last = newNode;\n      this.last.prev = this.first;\n      this.first.next = newNode;\n    } else {\n      newNode.prev = this.last;\n      this.last.next = newNode;\n      this.last = newNode;\n    }\n    return true;\n  }\n  dequeue() {\n    if (!this.first)\n      return null;\n    if (this.first === this.last) {\n      const target2 = this.first;\n      this.first = null;\n      this.last = null;\n      return target2.value;\n    }\n    const target = this.first;\n    this.first = target.next;\n    return target.value;\n  }\n};\n\n// pure.ts\nvar JS = class {\n  generateSecretKey() {\n    return _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.utils.randomPrivateKey();\n  }\n  getPublicKey(secretKey) {\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n  }\n  finalizeEvent(t, secretKey) {\n    const event = t;\n    event.pubkey = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.getPublicKey(secretKey));\n    event.id = getEventHash(event);\n    event.sig = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.sign(getEventHash(event), secretKey));\n    event[verifiedSymbol] = true;\n    return event;\n  }\n  verifyEvent(event) {\n    if (typeof event[verifiedSymbol] === \"boolean\")\n      return event[verifiedSymbol];\n    const hash = getEventHash(event);\n    if (hash !== event.id) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n    try {\n      const valid = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.schnorr.verify(event.sig, hash, event.pubkey);\n      event[verifiedSymbol] = valid;\n      return valid;\n    } catch (err) {\n      event[verifiedSymbol] = false;\n      return false;\n    }\n  }\n};\nfunction serializeEvent(evt) {\n  if (!validateEvent(evt))\n    throw new Error(\"can't serialize event with wrong or missing properties\");\n  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);\n}\nfunction getEventHash(event) {\n  let eventHash = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_1__.sha256)(utf8Encoder.encode(serializeEvent(event)));\n  return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(eventHash);\n}\nvar i = new JS();\nvar generateSecretKey = i.generateSecretKey;\nvar getPublicKey = i.getPublicKey;\nvar finalizeEvent = i.finalizeEvent;\nvar verifyEvent = i.verifyEvent;\n\n// kinds.ts\nvar ClientAuth = 22242;\n\n// filter.ts\nfunction matchFilter(filter, event) {\n  if (filter.ids && filter.ids.indexOf(event.id) === -1) {\n    return false;\n  }\n  if (filter.kinds && filter.kinds.indexOf(event.kind) === -1) {\n    return false;\n  }\n  if (filter.authors && filter.authors.indexOf(event.pubkey) === -1) {\n    return false;\n  }\n  for (let f in filter) {\n    if (f[0] === \"#\") {\n      let tagName = f.slice(1);\n      let values = filter[`#${tagName}`];\n      if (values && !event.tags.find(([t, v]) => t === f.slice(1) && values.indexOf(v) !== -1))\n        return false;\n    }\n  }\n  if (filter.since && event.created_at < filter.since)\n    return false;\n  if (filter.until && event.created_at > filter.until)\n    return false;\n  return true;\n}\nfunction matchFilters(filters, event) {\n  for (let i2 = 0; i2 < filters.length; i2++) {\n    if (matchFilter(filters[i2], event)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// fakejson.ts\nfunction getHex64(json, field) {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\nfunction getSubscriptionId(json) {\n  let idx = json.slice(0, 22).indexOf(`\"EVENT\"`);\n  if (idx === -1)\n    return null;\n  let pstart = json.slice(idx + 7 + 1).indexOf(`\"`);\n  if (pstart === -1)\n    return null;\n  let start = idx + 7 + 1 + pstart;\n  let pend = json.slice(start + 1, 80).indexOf(`\"`);\n  if (pend === -1)\n    return null;\n  let end = start + 1 + pend;\n  return json.slice(start + 1, end);\n}\n\n// nip42.ts\nfunction makeAuthEvent(relayURL, challenge) {\n  return {\n    kind: ClientAuth,\n    created_at: Math.floor(Date.now() / 1e3),\n    tags: [\n      [\"relay\", relayURL],\n      [\"challenge\", challenge]\n    ],\n    content: \"\"\n  };\n}\n\n// helpers.ts\nasync function yieldThread() {\n  return new Promise((resolve) => {\n    const ch = new MessageChannel();\n    const handler = () => {\n      ch.port1.removeEventListener(\"message\", handler);\n      resolve();\n    };\n    ch.port1.addEventListener(\"message\", handler);\n    ch.port2.postMessage(0);\n    ch.port1.start();\n  });\n}\nvar alwaysTrue = (t) => {\n  t[verifiedSymbol] = true;\n  return true;\n};\n\n// abstract-relay.ts\nvar AbstractRelay = class {\n  url;\n  _connected = false;\n  onclose = null;\n  onnotice = (msg) => console.debug(`NOTICE from ${this.url}: ${msg}`);\n  _onauth = null;\n  baseEoseTimeout = 4400;\n  connectionTimeout = 4400;\n  openSubs = /* @__PURE__ */ new Map();\n  connectionTimeoutHandle;\n  connectionPromise;\n  openCountRequests = /* @__PURE__ */ new Map();\n  openEventPublishes = /* @__PURE__ */ new Map();\n  ws;\n  incomingMessageQueue = new Queue();\n  queueRunning = false;\n  challenge;\n  serial = 0;\n  verifyEvent;\n  _WebSocket;\n  constructor(url, opts) {\n    this.url = normalizeURL(url);\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation || WebSocket;\n  }\n  static async connect(url, opts) {\n    const relay = new AbstractRelay(url, opts);\n    await relay.connect();\n    return relay;\n  }\n  closeAllSubscriptions(reason) {\n    for (let [_, sub] of this.openSubs) {\n      sub.close(reason);\n    }\n    this.openSubs.clear();\n    for (let [_, ep] of this.openEventPublishes) {\n      ep.reject(new Error(reason));\n    }\n    this.openEventPublishes.clear();\n    for (let [_, cr] of this.openCountRequests) {\n      cr.reject(new Error(reason));\n    }\n    this.openCountRequests.clear();\n  }\n  get connected() {\n    return this._connected;\n  }\n  async connect() {\n    if (this.connectionPromise)\n      return this.connectionPromise;\n    this.challenge = void 0;\n    this.connectionPromise = new Promise((resolve, reject) => {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        reject(\"connection timed out\");\n        this.connectionPromise = void 0;\n        this.onclose?.();\n        this.closeAllSubscriptions(\"relay connection timed out\");\n      }, this.connectionTimeout);\n      try {\n        this.ws = new this._WebSocket(this.url);\n      } catch (err) {\n        reject(err);\n        return;\n      }\n      this.ws.onopen = () => {\n        clearTimeout(this.connectionTimeoutHandle);\n        this._connected = true;\n        resolve();\n      };\n      this.ws.onerror = (ev) => {\n        reject(ev.message);\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection errored\");\n        }\n      };\n      this.ws.onclose = async () => {\n        if (this._connected) {\n          this._connected = false;\n          this.connectionPromise = void 0;\n          this.onclose?.();\n          this.closeAllSubscriptions(\"relay connection closed\");\n        }\n      };\n      this.ws.onmessage = this._onmessage.bind(this);\n    });\n    return this.connectionPromise;\n  }\n  async runQueue() {\n    this.queueRunning = true;\n    while (true) {\n      if (false === this.handleNext()) {\n        break;\n      }\n      await yieldThread();\n    }\n    this.queueRunning = false;\n  }\n  handleNext() {\n    const json = this.incomingMessageQueue.dequeue();\n    if (!json) {\n      return false;\n    }\n    const subid = getSubscriptionId(json);\n    if (subid) {\n      const so = this.openSubs.get(subid);\n      if (!so) {\n        return;\n      }\n      const id = getHex64(json, \"id\");\n      const alreadyHave = so.alreadyHaveEvent?.(id);\n      so.receivedEvent?.(this, id);\n      if (alreadyHave) {\n        return;\n      }\n    }\n    try {\n      let data = JSON.parse(json);\n      switch (data[0]) {\n        case \"EVENT\": {\n          const so = this.openSubs.get(data[1]);\n          const event = data[2];\n          if (this.verifyEvent(event) && matchFilters(so.filters, event)) {\n            so.onevent(event);\n          }\n          return;\n        }\n        case \"COUNT\": {\n          const id = data[1];\n          const payload = data[2];\n          const cr = this.openCountRequests.get(id);\n          if (cr) {\n            cr.resolve(payload.count);\n            this.openCountRequests.delete(id);\n          }\n          return;\n        }\n        case \"EOSE\": {\n          const so = this.openSubs.get(data[1]);\n          if (!so)\n            return;\n          so.receivedEose();\n          return;\n        }\n        case \"OK\": {\n          const id = data[1];\n          const ok = data[2];\n          const reason = data[3];\n          const ep = this.openEventPublishes.get(id);\n          if (ok)\n            ep.resolve(reason);\n          else\n            ep.reject(new Error(reason));\n          this.openEventPublishes.delete(id);\n          return;\n        }\n        case \"CLOSED\": {\n          const id = data[1];\n          const so = this.openSubs.get(id);\n          if (!so)\n            return;\n          so.closed = true;\n          so.close(data[2]);\n          return;\n        }\n        case \"NOTICE\":\n          this.onnotice(data[1]);\n          return;\n        case \"AUTH\": {\n          this.challenge = data[1];\n          this._onauth?.(data[1]);\n          return;\n        }\n      }\n    } catch (err) {\n      return;\n    }\n  }\n  async send(message) {\n    if (!this.connectionPromise)\n      throw new Error(\"sending on closed connection\");\n    this.connectionPromise.then(() => {\n      this.ws?.send(message);\n    });\n  }\n  async auth(signAuthEvent) {\n    if (!this.challenge)\n      throw new Error(\"can't perform auth, no challenge was received\");\n    const evt = await signAuthEvent(makeAuthEvent(this.url, this.challenge));\n    const ret = new Promise((resolve, reject) => {\n      this.openEventPublishes.set(evt.id, { resolve, reject });\n    });\n    this.send('[\"AUTH\",' + JSON.stringify(evt) + \"]\");\n    return ret;\n  }\n  async publish(event) {\n    const ret = new Promise((resolve, reject) => {\n      this.openEventPublishes.set(event.id, { resolve, reject });\n    });\n    this.send('[\"EVENT\",' + JSON.stringify(event) + \"]\");\n    return ret;\n  }\n  async count(filters, params) {\n    this.serial++;\n    const id = params?.id || \"count:\" + this.serial;\n    const ret = new Promise((resolve, reject) => {\n      this.openCountRequests.set(id, { resolve, reject });\n    });\n    this.send('[\"COUNT\",\"' + id + '\",' + JSON.stringify(filters).substring(1));\n    return ret;\n  }\n  subscribe(filters, params) {\n    const subscription = this.prepareSubscription(filters, params);\n    subscription.fire();\n    return subscription;\n  }\n  prepareSubscription(filters, params) {\n    this.serial++;\n    const id = params.id || \"sub:\" + this.serial;\n    const subscription = new Subscription(this, id, filters, params);\n    this.openSubs.set(id, subscription);\n    return subscription;\n  }\n  close() {\n    this.closeAllSubscriptions(\"relay connection closed by us\");\n    this._connected = false;\n    this.ws?.close();\n  }\n  _onmessage(ev) {\n    this.incomingMessageQueue.enqueue(ev.data);\n    if (!this.queueRunning) {\n      this.runQueue();\n    }\n  }\n};\nvar Subscription = class {\n  relay;\n  id;\n  closed = false;\n  eosed = false;\n  filters;\n  alreadyHaveEvent;\n  receivedEvent;\n  onevent;\n  oneose;\n  onclose;\n  eoseTimeout;\n  eoseTimeoutHandle;\n  constructor(relay, id, filters, params) {\n    this.relay = relay;\n    this.filters = filters;\n    this.id = id;\n    this.alreadyHaveEvent = params.alreadyHaveEvent;\n    this.receivedEvent = params.receivedEvent;\n    this.eoseTimeout = params.eoseTimeout || relay.baseEoseTimeout;\n    this.oneose = params.oneose;\n    this.onclose = params.onclose;\n    this.onevent = params.onevent || ((event) => {\n      console.warn(\n        `onevent() callback not defined for subscription '${this.id}' in relay ${this.relay.url}. event received:`,\n        event\n      );\n    });\n  }\n  fire() {\n    this.relay.send('[\"REQ\",\"' + this.id + '\",' + JSON.stringify(this.filters).substring(1));\n    this.eoseTimeoutHandle = setTimeout(this.receivedEose.bind(this), this.eoseTimeout);\n  }\n  receivedEose() {\n    if (this.eosed)\n      return;\n    clearTimeout(this.eoseTimeoutHandle);\n    this.eosed = true;\n    this.oneose?.();\n  }\n  close(reason = \"closed by caller\") {\n    if (!this.closed && this.relay.connected) {\n      this.relay.send('[\"CLOSE\",' + JSON.stringify(this.id) + \"]\");\n      this.closed = true;\n    }\n    this.relay.openSubs.delete(this.id);\n    this.onclose?.(reason);\n  }\n};\n\n// abstract-pool.ts\nvar AbstractSimplePool = class {\n  relays = /* @__PURE__ */ new Map();\n  seenOn = /* @__PURE__ */ new Map();\n  trackRelays = false;\n  verifyEvent;\n  trustedRelayURLs = /* @__PURE__ */ new Set();\n  _WebSocket;\n  constructor(opts) {\n    this.verifyEvent = opts.verifyEvent;\n    this._WebSocket = opts.websocketImplementation;\n  }\n  async ensureRelay(url, params) {\n    url = normalizeURL(url);\n    let relay = this.relays.get(url);\n    if (!relay) {\n      relay = new AbstractRelay(url, {\n        verifyEvent: this.trustedRelayURLs.has(url) ? alwaysTrue : this.verifyEvent,\n        websocketImplementation: this._WebSocket\n      });\n      if (params?.connectionTimeout)\n        relay.connectionTimeout = params.connectionTimeout;\n      this.relays.set(url, relay);\n    }\n    await relay.connect();\n    return relay;\n  }\n  close(relays) {\n    relays.map(normalizeURL).forEach((url) => {\n      this.relays.get(url)?.close();\n    });\n  }\n  subscribeMany(relays, filters, params) {\n    return this.subscribeManyMap(Object.fromEntries(relays.map((url) => [url, filters])), params);\n  }\n  subscribeManyMap(requests, params) {\n    if (this.trackRelays) {\n      params.receivedEvent = (relay, id) => {\n        let set = this.seenOn.get(id);\n        if (!set) {\n          set = /* @__PURE__ */ new Set();\n          this.seenOn.set(id, set);\n        }\n        set.add(relay);\n      };\n    }\n    const _knownIds = /* @__PURE__ */ new Set();\n    const subs = [];\n    const relaysLength = Object.keys(requests).length;\n    const eosesReceived = [];\n    let handleEose = (i2) => {\n      eosesReceived[i2] = true;\n      if (eosesReceived.filter((a) => a).length === relaysLength) {\n        params.oneose?.();\n        handleEose = () => {\n        };\n      }\n    };\n    const closesReceived = [];\n    let handleClose = (i2, reason) => {\n      handleEose(i2);\n      closesReceived[i2] = reason;\n      if (closesReceived.filter((a) => a).length === relaysLength) {\n        params.onclose?.(closesReceived);\n        handleClose = () => {\n        };\n      }\n    };\n    const localAlreadyHaveEventHandler = (id) => {\n      if (params.alreadyHaveEvent?.(id)) {\n        return true;\n      }\n      const have = _knownIds.has(id);\n      _knownIds.add(id);\n      return have;\n    };\n    const allOpened = Promise.all(\n      Object.entries(requests).map(async (req, i2, arr) => {\n        if (arr.indexOf(req) !== i2) {\n          handleClose(i2, \"duplicate url\");\n          return;\n        }\n        let [url, filters] = req;\n        url = normalizeURL(url);\n        let relay;\n        try {\n          relay = await this.ensureRelay(url, {\n            connectionTimeout: params.maxWait ? Math.max(params.maxWait * 0.8, params.maxWait - 1e3) : void 0\n          });\n        } catch (err) {\n          handleClose(i2, err?.message || String(err));\n          return;\n        }\n        let subscription = relay.subscribe(filters, {\n          ...params,\n          oneose: () => handleEose(i2),\n          onclose: (reason) => handleClose(i2, reason),\n          alreadyHaveEvent: localAlreadyHaveEventHandler,\n          eoseTimeout: params.maxWait\n        });\n        subs.push(subscription);\n      })\n    );\n    return {\n      async close() {\n        await allOpened;\n        subs.forEach((sub) => {\n          sub.close();\n        });\n      }\n    };\n  }\n  subscribeManyEose(relays, filters, params) {\n    const subcloser = this.subscribeMany(relays, filters, {\n      ...params,\n      oneose() {\n        subcloser.close();\n      }\n    });\n    return subcloser;\n  }\n  async querySync(relays, filter, params) {\n    return new Promise(async (resolve) => {\n      const events = [];\n      this.subscribeManyEose(relays, [filter], {\n        ...params,\n        onevent(event) {\n          events.push(event);\n        },\n        onclose(_) {\n          resolve(events);\n        }\n      });\n    });\n  }\n  async get(relays, filter, params) {\n    filter.limit = 1;\n    const events = await this.querySync(relays, filter, params);\n    events.sort((a, b) => b.created_at - a.created_at);\n    return events[0] || null;\n  }\n  publish(relays, event) {\n    return relays.map(normalizeURL).map(async (url, i2, arr) => {\n      if (arr.indexOf(url) !== i2) {\n        return Promise.reject(\"duplicate url\");\n      }\n      let r = await this.ensureRelay(url);\n      return r.publish(event);\n    });\n  }\n};\n\n// pool.ts\nvar _WebSocket;\ntry {\n  _WebSocket = WebSocket;\n} catch {\n}\nfunction useWebSocketImplementation(websocketImplementation) {\n  _WebSocket = websocketImplementation;\n}\nvar SimplePool = class extends AbstractSimplePool {\n  constructor() {\n    super({ verifyEvent, websocketImplementation: _WebSocket });\n  }\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbm9zdHItdG9vbHMvbGliL2VzbS9wb29sLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ2tEO0FBQ0Q7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsR0FBRztBQUN4QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzhDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0REFBTztBQUNsQjtBQUNBO0FBQ0EsV0FBVywrREFBVSxDQUFDLDREQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBVSxDQUFDLDREQUFPO0FBQ3JDO0FBQ0EsZ0JBQWdCLCtEQUFVLENBQUMsNERBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDREQUFPO0FBQzNCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBTTtBQUN4QixTQUFTLCtEQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUyxJQUFJLElBQUk7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlCQUFpQjtBQUM3RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlCQUFpQjtBQUN4RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFFBQVEsYUFBYSxlQUFlO0FBQ2hHO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0RBQWtEO0FBQzlEO0FBQ0E7QUFLRSIsInNvdXJjZXMiOlsid2VicGFjazovL25vc3RyLWxpbmUtY2xpZW50Ly4vbm9kZV9tb2R1bGVzL25vc3RyLXRvb2xzL2xpYi9lc20vcG9vbC5qcz82MDI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHB1cmUudHNcbmltcG9ydCB7IHNjaG5vcnIgfSBmcm9tIFwiQG5vYmxlL2N1cnZlcy9zZWNwMjU2azFcIjtcbmltcG9ydCB7IGJ5dGVzVG9IZXggfSBmcm9tIFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiO1xuXG4vLyBjb3JlLnRzXG52YXIgdmVyaWZpZWRTeW1ib2wgPSBTeW1ib2woXCJ2ZXJpZmllZFwiKTtcbnZhciBpc1JlY29yZCA9IChvYmopID0+IG9iaiBpbnN0YW5jZW9mIE9iamVjdDtcbmZ1bmN0aW9uIHZhbGlkYXRlRXZlbnQoZXZlbnQpIHtcbiAgaWYgKCFpc1JlY29yZChldmVudCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmtpbmQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNvbnRlbnQgIT09IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LmNyZWF0ZWRfYXQgIT09IFwibnVtYmVyXCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGV2ZW50LnB1YmtleSAhPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICghZXZlbnQucHVia2V5Lm1hdGNoKC9eW2EtZjAtOV17NjR9JC8pKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGV2ZW50LnRhZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGV2ZW50LnRhZ3MubGVuZ3RoOyBpMisrKSB7XG4gICAgbGV0IHRhZyA9IGV2ZW50LnRhZ3NbaTJdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YWcpKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGFnLmxlbmd0aDsgaisrKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ1tqXSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gcHVyZS50c1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCI7XG5cbi8vIHV0aWxzLnRzXG52YXIgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbnZhciB1dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gbm9ybWFsaXplVVJMKHVybCkge1xuICBpZiAodXJsLmluZGV4T2YoXCI6Ly9cIikgPT09IC0xKVxuICAgIHVybCA9IFwid3NzOi8vXCIgKyB1cmw7XG4gIGxldCBwID0gbmV3IFVSTCh1cmwpO1xuICBwLnBhdGhuYW1lID0gcC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rL2csIFwiL1wiKTtcbiAgaWYgKHAucGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpKVxuICAgIHAucGF0aG5hbWUgPSBwLnBhdGhuYW1lLnNsaWNlKDAsIC0xKTtcbiAgaWYgKHAucG9ydCA9PT0gXCI4MFwiICYmIHAucHJvdG9jb2wgPT09IFwid3M6XCIgfHwgcC5wb3J0ID09PSBcIjQ0M1wiICYmIHAucHJvdG9jb2wgPT09IFwid3NzOlwiKVxuICAgIHAucG9ydCA9IFwiXCI7XG4gIHAuc2VhcmNoUGFyYW1zLnNvcnQoKTtcbiAgcC5oYXNoID0gXCJcIjtcbiAgcmV0dXJuIHAudG9TdHJpbmcoKTtcbn1cbnZhciBRdWV1ZU5vZGUgPSBjbGFzcyB7XG4gIHZhbHVlO1xuICBuZXh0ID0gbnVsbDtcbiAgcHJldiA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnZhbHVlID0gbWVzc2FnZTtcbiAgfVxufTtcbnZhciBRdWV1ZSA9IGNsYXNzIHtcbiAgZmlyc3Q7XG4gIGxhc3Q7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgIHRoaXMubGFzdCA9IG51bGw7XG4gIH1cbiAgZW5xdWV1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG5ld05vZGUgPSBuZXcgUXVldWVOb2RlKHZhbHVlKTtcbiAgICBpZiAoIXRoaXMubGFzdCkge1xuICAgICAgdGhpcy5maXJzdCA9IG5ld05vZGU7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sYXN0ID09PSB0aGlzLmZpcnN0KSB7XG4gICAgICB0aGlzLmxhc3QgPSBuZXdOb2RlO1xuICAgICAgdGhpcy5sYXN0LnByZXYgPSB0aGlzLmZpcnN0O1xuICAgICAgdGhpcy5maXJzdC5uZXh0ID0gbmV3Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Tm9kZS5wcmV2ID0gdGhpcy5sYXN0O1xuICAgICAgdGhpcy5sYXN0Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgdGhpcy5sYXN0ID0gbmV3Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZGVxdWV1ZSgpIHtcbiAgICBpZiAoIXRoaXMuZmlyc3QpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAodGhpcy5maXJzdCA9PT0gdGhpcy5sYXN0KSB7XG4gICAgICBjb25zdCB0YXJnZXQyID0gdGhpcy5maXJzdDtcbiAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgICAgdGhpcy5sYXN0ID0gbnVsbDtcbiAgICAgIHJldHVybiB0YXJnZXQyLnZhbHVlO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmZpcnN0O1xuICAgIHRoaXMuZmlyc3QgPSB0YXJnZXQubmV4dDtcbiAgICByZXR1cm4gdGFyZ2V0LnZhbHVlO1xuICB9XG59O1xuXG4vLyBwdXJlLnRzXG52YXIgSlMgPSBjbGFzcyB7XG4gIGdlbmVyYXRlU2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBzY2hub3JyLnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgfVxuICBnZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSB7XG4gICAgcmV0dXJuIGJ5dGVzVG9IZXgoc2Nobm9yci5nZXRQdWJsaWNLZXkoc2VjcmV0S2V5KSk7XG4gIH1cbiAgZmluYWxpemVFdmVudCh0LCBzZWNyZXRLZXkpIHtcbiAgICBjb25zdCBldmVudCA9IHQ7XG4gICAgZXZlbnQucHVia2V5ID0gYnl0ZXNUb0hleChzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpKTtcbiAgICBldmVudC5pZCA9IGdldEV2ZW50SGFzaChldmVudCk7XG4gICAgZXZlbnQuc2lnID0gYnl0ZXNUb0hleChzY2hub3JyLnNpZ24oZ2V0RXZlbnRIYXNoKGV2ZW50KSwgc2VjcmV0S2V5KSk7XG4gICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gdHJ1ZTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbiAgdmVyaWZ5RXZlbnQoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9PT0gXCJib29sZWFuXCIpXG4gICAgICByZXR1cm4gZXZlbnRbdmVyaWZpZWRTeW1ib2xdO1xuICAgIGNvbnN0IGhhc2ggPSBnZXRFdmVudEhhc2goZXZlbnQpO1xuICAgIGlmIChoYXNoICE9PSBldmVudC5pZCkge1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWxpZCA9IHNjaG5vcnIudmVyaWZ5KGV2ZW50LnNpZywgaGFzaCwgZXZlbnQucHVia2V5KTtcbiAgICAgIGV2ZW50W3ZlcmlmaWVkU3ltYm9sXSA9IHZhbGlkO1xuICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXZlbnRbdmVyaWZpZWRTeW1ib2xdID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc2VyaWFsaXplRXZlbnQoZXZ0KSB7XG4gIGlmICghdmFsaWRhdGVFdmVudChldnQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHNlcmlhbGl6ZSBldmVudCB3aXRoIHdyb25nIG9yIG1pc3NpbmcgcHJvcGVydGllc1wiKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFswLCBldnQucHVia2V5LCBldnQuY3JlYXRlZF9hdCwgZXZ0LmtpbmQsIGV2dC50YWdzLCBldnQuY29udGVudF0pO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRIYXNoKGV2ZW50KSB7XG4gIGxldCBldmVudEhhc2ggPSBzaGEyNTYodXRmOEVuY29kZXIuZW5jb2RlKHNlcmlhbGl6ZUV2ZW50KGV2ZW50KSkpO1xuICByZXR1cm4gYnl0ZXNUb0hleChldmVudEhhc2gpO1xufVxudmFyIGkgPSBuZXcgSlMoKTtcbnZhciBnZW5lcmF0ZVNlY3JldEtleSA9IGkuZ2VuZXJhdGVTZWNyZXRLZXk7XG52YXIgZ2V0UHVibGljS2V5ID0gaS5nZXRQdWJsaWNLZXk7XG52YXIgZmluYWxpemVFdmVudCA9IGkuZmluYWxpemVFdmVudDtcbnZhciB2ZXJpZnlFdmVudCA9IGkudmVyaWZ5RXZlbnQ7XG5cbi8vIGtpbmRzLnRzXG52YXIgQ2xpZW50QXV0aCA9IDIyMjQyO1xuXG4vLyBmaWx0ZXIudHNcbmZ1bmN0aW9uIG1hdGNoRmlsdGVyKGZpbHRlciwgZXZlbnQpIHtcbiAgaWYgKGZpbHRlci5pZHMgJiYgZmlsdGVyLmlkcy5pbmRleE9mKGV2ZW50LmlkKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5raW5kcyAmJiBmaWx0ZXIua2luZHMuaW5kZXhPZihldmVudC5raW5kKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbHRlci5hdXRob3JzICYmIGZpbHRlci5hdXRob3JzLmluZGV4T2YoZXZlbnQucHVia2V5KSA9PT0gLTEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgZiBpbiBmaWx0ZXIpIHtcbiAgICBpZiAoZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgIGxldCB0YWdOYW1lID0gZi5zbGljZSgxKTtcbiAgICAgIGxldCB2YWx1ZXMgPSBmaWx0ZXJbYCMke3RhZ05hbWV9YF07XG4gICAgICBpZiAodmFsdWVzICYmICFldmVudC50YWdzLmZpbmQoKFt0LCB2XSkgPT4gdCA9PT0gZi5zbGljZSgxKSAmJiB2YWx1ZXMuaW5kZXhPZih2KSAhPT0gLTEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmIChmaWx0ZXIuc2luY2UgJiYgZXZlbnQuY3JlYXRlZF9hdCA8IGZpbHRlci5zaW5jZSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChmaWx0ZXIudW50aWwgJiYgZXZlbnQuY3JlYXRlZF9hdCA+IGZpbHRlci51bnRpbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbWF0Y2hGaWx0ZXJzKGZpbHRlcnMsIGV2ZW50KSB7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBmaWx0ZXJzLmxlbmd0aDsgaTIrKykge1xuICAgIGlmIChtYXRjaEZpbHRlcihmaWx0ZXJzW2kyXSwgZXZlbnQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBmYWtlanNvbi50c1xuZnVuY3Rpb24gZ2V0SGV4NjQoanNvbiwgZmllbGQpIHtcbiAgbGV0IGxlbiA9IGZpZWxkLmxlbmd0aCArIDM7XG4gIGxldCBpZHggPSBqc29uLmluZGV4T2YoYFwiJHtmaWVsZH1cIjpgKSArIGxlbjtcbiAgbGV0IHMgPSBqc29uLnNsaWNlKGlkeCkuaW5kZXhPZihgXCJgKSArIGlkeCArIDE7XG4gIHJldHVybiBqc29uLnNsaWNlKHMsIHMgKyA2NCk7XG59XG5mdW5jdGlvbiBnZXRTdWJzY3JpcHRpb25JZChqc29uKSB7XG4gIGxldCBpZHggPSBqc29uLnNsaWNlKDAsIDIyKS5pbmRleE9mKGBcIkVWRU5UXCJgKTtcbiAgaWYgKGlkeCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBwc3RhcnQgPSBqc29uLnNsaWNlKGlkeCArIDcgKyAxKS5pbmRleE9mKGBcImApO1xuICBpZiAocHN0YXJ0ID09PSAtMSlcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHN0YXJ0ID0gaWR4ICsgNyArIDEgKyBwc3RhcnQ7XG4gIGxldCBwZW5kID0ganNvbi5zbGljZShzdGFydCArIDEsIDgwKS5pbmRleE9mKGBcImApO1xuICBpZiAocGVuZCA9PT0gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBlbmQgPSBzdGFydCArIDEgKyBwZW5kO1xuICByZXR1cm4ganNvbi5zbGljZShzdGFydCArIDEsIGVuZCk7XG59XG5cbi8vIG5pcDQyLnRzXG5mdW5jdGlvbiBtYWtlQXV0aEV2ZW50KHJlbGF5VVJMLCBjaGFsbGVuZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBDbGllbnRBdXRoLFxuICAgIGNyZWF0ZWRfYXQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDFlMyksXG4gICAgdGFnczogW1xuICAgICAgW1wicmVsYXlcIiwgcmVsYXlVUkxdLFxuICAgICAgW1wiY2hhbGxlbmdlXCIsIGNoYWxsZW5nZV1cbiAgICBdLFxuICAgIGNvbnRlbnQ6IFwiXCJcbiAgfTtcbn1cblxuLy8gaGVscGVycy50c1xuYXN5bmMgZnVuY3Rpb24geWllbGRUaHJlYWQoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGNoID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgIGNoLnBvcnQxLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZXIpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG4gICAgY2gucG9ydDEuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG4gICAgY2gucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgY2gucG9ydDEuc3RhcnQoKTtcbiAgfSk7XG59XG52YXIgYWx3YXlzVHJ1ZSA9ICh0KSA9PiB7XG4gIHRbdmVyaWZpZWRTeW1ib2xdID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vLyBhYnN0cmFjdC1yZWxheS50c1xudmFyIEFic3RyYWN0UmVsYXkgPSBjbGFzcyB7XG4gIHVybDtcbiAgX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICBvbmNsb3NlID0gbnVsbDtcbiAgb25ub3RpY2UgPSAobXNnKSA9PiBjb25zb2xlLmRlYnVnKGBOT1RJQ0UgZnJvbSAke3RoaXMudXJsfTogJHttc2d9YCk7XG4gIF9vbmF1dGggPSBudWxsO1xuICBiYXNlRW9zZVRpbWVvdXQgPSA0NDAwO1xuICBjb25uZWN0aW9uVGltZW91dCA9IDQ0MDA7XG4gIG9wZW5TdWJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29ubmVjdGlvblRpbWVvdXRIYW5kbGU7XG4gIGNvbm5lY3Rpb25Qcm9taXNlO1xuICBvcGVuQ291bnRSZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIG9wZW5FdmVudFB1Ymxpc2hlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHdzO1xuICBpbmNvbWluZ01lc3NhZ2VRdWV1ZSA9IG5ldyBRdWV1ZSgpO1xuICBxdWV1ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgY2hhbGxlbmdlO1xuICBzZXJpYWwgPSAwO1xuICB2ZXJpZnlFdmVudDtcbiAgX1dlYlNvY2tldDtcbiAgY29uc3RydWN0b3IodXJsLCBvcHRzKSB7XG4gICAgdGhpcy51cmwgPSBub3JtYWxpemVVUkwodXJsKTtcbiAgICB0aGlzLnZlcmlmeUV2ZW50ID0gb3B0cy52ZXJpZnlFdmVudDtcbiAgICB0aGlzLl9XZWJTb2NrZXQgPSBvcHRzLndlYnNvY2tldEltcGxlbWVudGF0aW9uIHx8IFdlYlNvY2tldDtcbiAgfVxuICBzdGF0aWMgYXN5bmMgY29ubmVjdCh1cmwsIG9wdHMpIHtcbiAgICBjb25zdCByZWxheSA9IG5ldyBBYnN0cmFjdFJlbGF5KHVybCwgb3B0cyk7XG4gICAgYXdhaXQgcmVsYXkuY29ubmVjdCgpO1xuICAgIHJldHVybiByZWxheTtcbiAgfVxuICBjbG9zZUFsbFN1YnNjcmlwdGlvbnMocmVhc29uKSB7XG4gICAgZm9yIChsZXQgW18sIHN1Yl0gb2YgdGhpcy5vcGVuU3Vicykge1xuICAgICAgc3ViLmNsb3NlKHJlYXNvbik7XG4gICAgfVxuICAgIHRoaXMub3BlblN1YnMuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBbXywgZXBdIG9mIHRoaXMub3BlbkV2ZW50UHVibGlzaGVzKSB7XG4gICAgICBlcC5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgIH1cbiAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5jbGVhcigpO1xuICAgIGZvciAobGV0IFtfLCBjcl0gb2YgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cykge1xuICAgICAgY3IucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICB9XG4gICAgdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5jbGVhcigpO1xuICB9XG4gIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3RlZDtcbiAgfVxuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLmNvbm5lY3Rpb25Qcm9taXNlKVxuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gICAgdGhpcy5jaGFsbGVuZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvblRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KFwiY29ubmVjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblByb21pc2UgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgIHRoaXMuY2xvc2VBbGxTdWJzY3JpcHRpb25zKFwicmVsYXkgY29ubmVjdGlvbiB0aW1lZCBvdXRcIik7XG4gICAgICB9LCB0aGlzLmNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgdGhpcy5fV2ViU29ja2V0KHRoaXMudXJsKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25UaW1lb3V0SGFuZGxlKTtcbiAgICAgICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25lcnJvciA9IChldikgPT4ge1xuICAgICAgICByZWplY3QoZXYubWVzc2FnZSk7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGVycm9yZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLndzLm9uY2xvc2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qcm9taXNlID0gdm9pZCAwO1xuICAgICAgICAgIHRoaXMub25jbG9zZT8uKCk7XG4gICAgICAgICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5fb25tZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvblByb21pc2U7XG4gIH1cbiAgYXN5bmMgcnVuUXVldWUoKSB7XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSB0cnVlO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IHRoaXMuaGFuZGxlTmV4dCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXdhaXQgeWllbGRUaHJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5xdWV1ZVJ1bm5pbmcgPSBmYWxzZTtcbiAgfVxuICBoYW5kbGVOZXh0KCkge1xuICAgIGNvbnN0IGpzb24gPSB0aGlzLmluY29taW5nTWVzc2FnZVF1ZXVlLmRlcXVldWUoKTtcbiAgICBpZiAoIWpzb24pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc3ViaWQgPSBnZXRTdWJzY3JpcHRpb25JZChqc29uKTtcbiAgICBpZiAoc3ViaWQpIHtcbiAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoc3ViaWQpO1xuICAgICAgaWYgKCFzbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpZCA9IGdldEhleDY0KGpzb24sIFwiaWRcIik7XG4gICAgICBjb25zdCBhbHJlYWR5SGF2ZSA9IHNvLmFscmVhZHlIYXZlRXZlbnQ/LihpZCk7XG4gICAgICBzby5yZWNlaXZlZEV2ZW50Py4odGhpcywgaWQpO1xuICAgICAgaWYgKGFscmVhZHlIYXZlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgIHN3aXRjaCAoZGF0YVswXSkge1xuICAgICAgICBjYXNlIFwiRVZFTlRcIjoge1xuICAgICAgICAgIGNvbnN0IHNvID0gdGhpcy5vcGVuU3Vicy5nZXQoZGF0YVsxXSk7XG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBkYXRhWzJdO1xuICAgICAgICAgIGlmICh0aGlzLnZlcmlmeUV2ZW50KGV2ZW50KSAmJiBtYXRjaEZpbHRlcnMoc28uZmlsdGVycywgZXZlbnQpKSB7XG4gICAgICAgICAgICBzby5vbmV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJDT1VOVFwiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBkYXRhWzJdO1xuICAgICAgICAgIGNvbnN0IGNyID0gdGhpcy5vcGVuQ291bnRSZXF1ZXN0cy5nZXQoaWQpO1xuICAgICAgICAgIGlmIChjcikge1xuICAgICAgICAgICAgY3IucmVzb2x2ZShwYXlsb2FkLmNvdW50KTtcbiAgICAgICAgICAgIHRoaXMub3BlbkNvdW50UmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJFT1NFXCI6IHtcbiAgICAgICAgICBjb25zdCBzbyA9IHRoaXMub3BlblN1YnMuZ2V0KGRhdGFbMV0pO1xuICAgICAgICAgIGlmICghc28pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgc28ucmVjZWl2ZWRFb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJPS1wiOiB7XG4gICAgICAgICAgY29uc3QgaWQgPSBkYXRhWzFdO1xuICAgICAgICAgIGNvbnN0IG9rID0gZGF0YVsyXTtcbiAgICAgICAgICBjb25zdCByZWFzb24gPSBkYXRhWzNdO1xuICAgICAgICAgIGNvbnN0IGVwID0gdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAob2spXG4gICAgICAgICAgICBlcC5yZXNvbHZlKHJlYXNvbik7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZXAucmVqZWN0KG5ldyBFcnJvcihyZWFzb24pKTtcbiAgICAgICAgICB0aGlzLm9wZW5FdmVudFB1Ymxpc2hlcy5kZWxldGUoaWQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiQ0xPU0VEXCI6IHtcbiAgICAgICAgICBjb25zdCBpZCA9IGRhdGFbMV07XG4gICAgICAgICAgY29uc3Qgc28gPSB0aGlzLm9wZW5TdWJzLmdldChpZCk7XG4gICAgICAgICAgaWYgKCFzbylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBzby5jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgIHNvLmNsb3NlKGRhdGFbMl0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiTk9USUNFXCI6XG4gICAgICAgICAgdGhpcy5vbm5vdGljZShkYXRhWzFdKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJBVVRIXCI6IHtcbiAgICAgICAgICB0aGlzLmNoYWxsZW5nZSA9IGRhdGFbMV07XG4gICAgICAgICAgdGhpcy5fb25hdXRoPy4oZGF0YVsxXSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGFzeW5jIHNlbmQobWVzc2FnZSkge1xuICAgIGlmICghdGhpcy5jb25uZWN0aW9uUHJvbWlzZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNlbmRpbmcgb24gY2xvc2VkIGNvbm5lY3Rpb25cIik7XG4gICAgdGhpcy5jb25uZWN0aW9uUHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMud3M/LnNlbmQobWVzc2FnZSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgYXV0aChzaWduQXV0aEV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmNoYWxsZW5nZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbid0IHBlcmZvcm0gYXV0aCwgbm8gY2hhbGxlbmdlIHdhcyByZWNlaXZlZFwiKTtcbiAgICBjb25zdCBldnQgPSBhd2FpdCBzaWduQXV0aEV2ZW50KG1ha2VBdXRoRXZlbnQodGhpcy51cmwsIHRoaXMuY2hhbGxlbmdlKSk7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2dC5pZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJBVVRIXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2dCkgKyBcIl1cIik7XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBhc3luYyBwdWJsaXNoKGV2ZW50KSB7XG4gICAgY29uc3QgcmV0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vcGVuRXZlbnRQdWJsaXNoZXMuc2V0KGV2ZW50LmlkLCB7IHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoJ1tcIkVWRU5UXCIsJyArIEpTT04uc3RyaW5naWZ5KGV2ZW50KSArIFwiXVwiKTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIGFzeW5jIGNvdW50KGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXM/LmlkIHx8IFwiY291bnQ6XCIgKyB0aGlzLnNlcmlhbDtcbiAgICBjb25zdCByZXQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9wZW5Db3VudFJlcXVlc3RzLnNldChpZCwgeyByZXNvbHZlLCByZWplY3QgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kKCdbXCJDT1VOVFwiLFwiJyArIGlkICsgJ1wiLCcgKyBKU09OLnN0cmluZ2lmeShmaWx0ZXJzKS5zdWJzdHJpbmcoMSkpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbiAgc3Vic2NyaWJlKGZpbHRlcnMsIHBhcmFtcykge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMucHJlcGFyZVN1YnNjcmlwdGlvbihmaWx0ZXJzLCBwYXJhbXMpO1xuICAgIHN1YnNjcmlwdGlvbi5maXJlKCk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxuICBwcmVwYXJlU3Vic2NyaXB0aW9uKGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMuc2VyaWFsKys7XG4gICAgY29uc3QgaWQgPSBwYXJhbXMuaWQgfHwgXCJzdWI6XCIgKyB0aGlzLnNlcmlhbDtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRoaXMsIGlkLCBmaWx0ZXJzLCBwYXJhbXMpO1xuICAgIHRoaXMub3BlblN1YnMuc2V0KGlkLCBzdWJzY3JpcHRpb24pO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5jbG9zZUFsbFN1YnNjcmlwdGlvbnMoXCJyZWxheSBjb25uZWN0aW9uIGNsb3NlZCBieSB1c1wiKTtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLndzPy5jbG9zZSgpO1xuICB9XG4gIF9vbm1lc3NhZ2UoZXYpIHtcbiAgICB0aGlzLmluY29taW5nTWVzc2FnZVF1ZXVlLmVucXVldWUoZXYuZGF0YSk7XG4gICAgaWYgKCF0aGlzLnF1ZXVlUnVubmluZykge1xuICAgICAgdGhpcy5ydW5RdWV1ZSgpO1xuICAgIH1cbiAgfVxufTtcbnZhciBTdWJzY3JpcHRpb24gPSBjbGFzcyB7XG4gIHJlbGF5O1xuICBpZDtcbiAgY2xvc2VkID0gZmFsc2U7XG4gIGVvc2VkID0gZmFsc2U7XG4gIGZpbHRlcnM7XG4gIGFscmVhZHlIYXZlRXZlbnQ7XG4gIHJlY2VpdmVkRXZlbnQ7XG4gIG9uZXZlbnQ7XG4gIG9uZW9zZTtcbiAgb25jbG9zZTtcbiAgZW9zZVRpbWVvdXQ7XG4gIGVvc2VUaW1lb3V0SGFuZGxlO1xuICBjb25zdHJ1Y3RvcihyZWxheSwgaWQsIGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHRoaXMucmVsYXkgPSByZWxheTtcbiAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmFscmVhZHlIYXZlRXZlbnQgPSBwYXJhbXMuYWxyZWFkeUhhdmVFdmVudDtcbiAgICB0aGlzLnJlY2VpdmVkRXZlbnQgPSBwYXJhbXMucmVjZWl2ZWRFdmVudDtcbiAgICB0aGlzLmVvc2VUaW1lb3V0ID0gcGFyYW1zLmVvc2VUaW1lb3V0IHx8IHJlbGF5LmJhc2VFb3NlVGltZW91dDtcbiAgICB0aGlzLm9uZW9zZSA9IHBhcmFtcy5vbmVvc2U7XG4gICAgdGhpcy5vbmNsb3NlID0gcGFyYW1zLm9uY2xvc2U7XG4gICAgdGhpcy5vbmV2ZW50ID0gcGFyYW1zLm9uZXZlbnQgfHwgKChldmVudCkgPT4ge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgb25ldmVudCgpIGNhbGxiYWNrIG5vdCBkZWZpbmVkIGZvciBzdWJzY3JpcHRpb24gJyR7dGhpcy5pZH0nIGluIHJlbGF5ICR7dGhpcy5yZWxheS51cmx9LiBldmVudCByZWNlaXZlZDpgLFxuICAgICAgICBldmVudFxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICBmaXJlKCkge1xuICAgIHRoaXMucmVsYXkuc2VuZCgnW1wiUkVRXCIsXCInICsgdGhpcy5pZCArICdcIiwnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5maWx0ZXJzKS5zdWJzdHJpbmcoMSkpO1xuICAgIHRoaXMuZW9zZVRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KHRoaXMucmVjZWl2ZWRFb3NlLmJpbmQodGhpcyksIHRoaXMuZW9zZVRpbWVvdXQpO1xuICB9XG4gIHJlY2VpdmVkRW9zZSgpIHtcbiAgICBpZiAodGhpcy5lb3NlZClcbiAgICAgIHJldHVybjtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5lb3NlVGltZW91dEhhbmRsZSk7XG4gICAgdGhpcy5lb3NlZCA9IHRydWU7XG4gICAgdGhpcy5vbmVvc2U/LigpO1xuICB9XG4gIGNsb3NlKHJlYXNvbiA9IFwiY2xvc2VkIGJ5IGNhbGxlclwiKSB7XG4gICAgaWYgKCF0aGlzLmNsb3NlZCAmJiB0aGlzLnJlbGF5LmNvbm5lY3RlZCkge1xuICAgICAgdGhpcy5yZWxheS5zZW5kKCdbXCJDTE9TRVwiLCcgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmlkKSArIFwiXVwiKTtcbiAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5yZWxheS5vcGVuU3Vicy5kZWxldGUodGhpcy5pZCk7XG4gICAgdGhpcy5vbmNsb3NlPy4ocmVhc29uKTtcbiAgfVxufTtcblxuLy8gYWJzdHJhY3QtcG9vbC50c1xudmFyIEFic3RyYWN0U2ltcGxlUG9vbCA9IGNsYXNzIHtcbiAgcmVsYXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc2Vlbk9uID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgdHJhY2tSZWxheXMgPSBmYWxzZTtcbiAgdmVyaWZ5RXZlbnQ7XG4gIHRydXN0ZWRSZWxheVVSTHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBfV2ViU29ja2V0O1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy52ZXJpZnlFdmVudCA9IG9wdHMudmVyaWZ5RXZlbnQ7XG4gICAgdGhpcy5fV2ViU29ja2V0ID0gb3B0cy53ZWJzb2NrZXRJbXBsZW1lbnRhdGlvbjtcbiAgfVxuICBhc3luYyBlbnN1cmVSZWxheSh1cmwsIHBhcmFtcykge1xuICAgIHVybCA9IG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgIGxldCByZWxheSA9IHRoaXMucmVsYXlzLmdldCh1cmwpO1xuICAgIGlmICghcmVsYXkpIHtcbiAgICAgIHJlbGF5ID0gbmV3IEFic3RyYWN0UmVsYXkodXJsLCB7XG4gICAgICAgIHZlcmlmeUV2ZW50OiB0aGlzLnRydXN0ZWRSZWxheVVSTHMuaGFzKHVybCkgPyBhbHdheXNUcnVlIDogdGhpcy52ZXJpZnlFdmVudCxcbiAgICAgICAgd2Vic29ja2V0SW1wbGVtZW50YXRpb246IHRoaXMuX1dlYlNvY2tldFxuICAgICAgfSk7XG4gICAgICBpZiAocGFyYW1zPy5jb25uZWN0aW9uVGltZW91dClcbiAgICAgICAgcmVsYXkuY29ubmVjdGlvblRpbWVvdXQgPSBwYXJhbXMuY29ubmVjdGlvblRpbWVvdXQ7XG4gICAgICB0aGlzLnJlbGF5cy5zZXQodXJsLCByZWxheSk7XG4gICAgfVxuICAgIGF3YWl0IHJlbGF5LmNvbm5lY3QoKTtcbiAgICByZXR1cm4gcmVsYXk7XG4gIH1cbiAgY2xvc2UocmVsYXlzKSB7XG4gICAgcmVsYXlzLm1hcChub3JtYWxpemVVUkwpLmZvckVhY2goKHVybCkgPT4ge1xuICAgICAgdGhpcy5yZWxheXMuZ2V0KHVybCk/LmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgc3Vic2NyaWJlTWFueShyZWxheXMsIGZpbHRlcnMsIHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZU1hbnlNYXAoT2JqZWN0LmZyb21FbnRyaWVzKHJlbGF5cy5tYXAoKHVybCkgPT4gW3VybCwgZmlsdGVyc10pKSwgcGFyYW1zKTtcbiAgfVxuICBzdWJzY3JpYmVNYW55TWFwKHJlcXVlc3RzLCBwYXJhbXMpIHtcbiAgICBpZiAodGhpcy50cmFja1JlbGF5cykge1xuICAgICAgcGFyYW1zLnJlY2VpdmVkRXZlbnQgPSAocmVsYXksIGlkKSA9PiB7XG4gICAgICAgIGxldCBzZXQgPSB0aGlzLnNlZW5Pbi5nZXQoaWQpO1xuICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgIHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgdGhpcy5zZWVuT24uc2V0KGlkLCBzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHNldC5hZGQocmVsYXkpO1xuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgX2tub3duSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCBzdWJzID0gW107XG4gICAgY29uc3QgcmVsYXlzTGVuZ3RoID0gT2JqZWN0LmtleXMocmVxdWVzdHMpLmxlbmd0aDtcbiAgICBjb25zdCBlb3Nlc1JlY2VpdmVkID0gW107XG4gICAgbGV0IGhhbmRsZUVvc2UgPSAoaTIpID0+IHtcbiAgICAgIGVvc2VzUmVjZWl2ZWRbaTJdID0gdHJ1ZTtcbiAgICAgIGlmIChlb3Nlc1JlY2VpdmVkLmZpbHRlcigoYSkgPT4gYSkubGVuZ3RoID09PSByZWxheXNMZW5ndGgpIHtcbiAgICAgICAgcGFyYW1zLm9uZW9zZT8uKCk7XG4gICAgICAgIGhhbmRsZUVvc2UgPSAoKSA9PiB7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjbG9zZXNSZWNlaXZlZCA9IFtdO1xuICAgIGxldCBoYW5kbGVDbG9zZSA9IChpMiwgcmVhc29uKSA9PiB7XG4gICAgICBoYW5kbGVFb3NlKGkyKTtcbiAgICAgIGNsb3Nlc1JlY2VpdmVkW2kyXSA9IHJlYXNvbjtcbiAgICAgIGlmIChjbG9zZXNSZWNlaXZlZC5maWx0ZXIoKGEpID0+IGEpLmxlbmd0aCA9PT0gcmVsYXlzTGVuZ3RoKSB7XG4gICAgICAgIHBhcmFtcy5vbmNsb3NlPy4oY2xvc2VzUmVjZWl2ZWQpO1xuICAgICAgICBoYW5kbGVDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxvY2FsQWxyZWFkeUhhdmVFdmVudEhhbmRsZXIgPSAoaWQpID0+IHtcbiAgICAgIGlmIChwYXJhbXMuYWxyZWFkeUhhdmVFdmVudD8uKGlkKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhdmUgPSBfa25vd25JZHMuaGFzKGlkKTtcbiAgICAgIF9rbm93bklkcy5hZGQoaWQpO1xuICAgICAgcmV0dXJuIGhhdmU7XG4gICAgfTtcbiAgICBjb25zdCBhbGxPcGVuZWQgPSBQcm9taXNlLmFsbChcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJlcXVlc3RzKS5tYXAoYXN5bmMgKHJlcSwgaTIsIGFycikgPT4ge1xuICAgICAgICBpZiAoYXJyLmluZGV4T2YocmVxKSAhPT0gaTIpIHtcbiAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgXCJkdXBsaWNhdGUgdXJsXCIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgW3VybCwgZmlsdGVyc10gPSByZXE7XG4gICAgICAgIHVybCA9IG5vcm1hbGl6ZVVSTCh1cmwpO1xuICAgICAgICBsZXQgcmVsYXk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVsYXkgPSBhd2FpdCB0aGlzLmVuc3VyZVJlbGF5KHVybCwge1xuICAgICAgICAgICAgY29ubmVjdGlvblRpbWVvdXQ6IHBhcmFtcy5tYXhXYWl0ID8gTWF0aC5tYXgocGFyYW1zLm1heFdhaXQgKiAwLjgsIHBhcmFtcy5tYXhXYWl0IC0gMWUzKSA6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBoYW5kbGVDbG9zZShpMiwgZXJyPy5tZXNzYWdlIHx8IFN0cmluZyhlcnIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHJlbGF5LnN1YnNjcmliZShmaWx0ZXJzLCB7XG4gICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgIG9uZW9zZTogKCkgPT4gaGFuZGxlRW9zZShpMiksXG4gICAgICAgICAgb25jbG9zZTogKHJlYXNvbikgPT4gaGFuZGxlQ2xvc2UoaTIsIHJlYXNvbiksXG4gICAgICAgICAgYWxyZWFkeUhhdmVFdmVudDogbG9jYWxBbHJlYWR5SGF2ZUV2ZW50SGFuZGxlcixcbiAgICAgICAgICBlb3NlVGltZW91dDogcGFyYW1zLm1heFdhaXRcbiAgICAgICAgfSk7XG4gICAgICAgIHN1YnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiB7XG4gICAgICBhc3luYyBjbG9zZSgpIHtcbiAgICAgICAgYXdhaXQgYWxsT3BlbmVkO1xuICAgICAgICBzdWJzLmZvckVhY2goKHN1YikgPT4ge1xuICAgICAgICAgIHN1Yi5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHN1YnNjcmliZU1hbnlFb3NlKHJlbGF5cywgZmlsdGVycywgcGFyYW1zKSB7XG4gICAgY29uc3Qgc3ViY2xvc2VyID0gdGhpcy5zdWJzY3JpYmVNYW55KHJlbGF5cywgZmlsdGVycywge1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgb25lb3NlKCkge1xuICAgICAgICBzdWJjbG9zZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc3ViY2xvc2VyO1xuICB9XG4gIGFzeW5jIHF1ZXJ5U3luYyhyZWxheXMsIGZpbHRlciwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICAgIHRoaXMuc3Vic2NyaWJlTWFueUVvc2UocmVsYXlzLCBbZmlsdGVyXSwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIG9uZXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICBldmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uY2xvc2UoXykge1xuICAgICAgICAgIHJlc29sdmUoZXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgZ2V0KHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpIHtcbiAgICBmaWx0ZXIubGltaXQgPSAxO1xuICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHRoaXMucXVlcnlTeW5jKHJlbGF5cywgZmlsdGVyLCBwYXJhbXMpO1xuICAgIGV2ZW50cy5zb3J0KChhLCBiKSA9PiBiLmNyZWF0ZWRfYXQgLSBhLmNyZWF0ZWRfYXQpO1xuICAgIHJldHVybiBldmVudHNbMF0gfHwgbnVsbDtcbiAgfVxuICBwdWJsaXNoKHJlbGF5cywgZXZlbnQpIHtcbiAgICByZXR1cm4gcmVsYXlzLm1hcChub3JtYWxpemVVUkwpLm1hcChhc3luYyAodXJsLCBpMiwgYXJyKSA9PiB7XG4gICAgICBpZiAoYXJyLmluZGV4T2YodXJsKSAhPT0gaTIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiZHVwbGljYXRlIHVybFwiKTtcbiAgICAgIH1cbiAgICAgIGxldCByID0gYXdhaXQgdGhpcy5lbnN1cmVSZWxheSh1cmwpO1xuICAgICAgcmV0dXJuIHIucHVibGlzaChldmVudCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHBvb2wudHNcbnZhciBfV2ViU29ja2V0O1xudHJ5IHtcbiAgX1dlYlNvY2tldCA9IFdlYlNvY2tldDtcbn0gY2F0Y2gge1xufVxuZnVuY3Rpb24gdXNlV2ViU29ja2V0SW1wbGVtZW50YXRpb24od2Vic29ja2V0SW1wbGVtZW50YXRpb24pIHtcbiAgX1dlYlNvY2tldCA9IHdlYnNvY2tldEltcGxlbWVudGF0aW9uO1xufVxudmFyIFNpbXBsZVBvb2wgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0U2ltcGxlUG9vbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgdmVyaWZ5RXZlbnQsIHdlYnNvY2tldEltcGxlbWVudGF0aW9uOiBfV2ViU29ja2V0IH0pO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQWJzdHJhY3RTaW1wbGVQb29sLFxuICBTaW1wbGVQb29sLFxuICB1c2VXZWJTb2NrZXRJbXBsZW1lbnRhdGlvblxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nostr-tools/lib/esm/pool.js\n");

/***/ })

};
;